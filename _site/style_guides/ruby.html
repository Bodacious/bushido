<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<title></title>

<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css">

<link rel="stylesheet" href="/assets/bushido.css" type="text/css" media="all">

<!-- Latest compiled and minified JavaScript -->
<script src="https://code.jquery.com/jquery-git2.min.js"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>

<script src="/assets/vendor/toc.js"></script>
<script src="/assets/bushido.js"></script>

  </head>
  <body>
    <div class="container">
      <div class="row">
        <div class="col-xs-12 col-sm-3">
          <div id="toc"></div>
        </div>
        <div class="col-xs-12 col-sm-9">
          <h2>Katana's Ruby Style Guide</h2>

<p>This style guide for writing Ruby is based closely on <a href="https://github.com/bbatsov/ruby-style-guide">Bozhidar Batsov’s Ruby Style Guide</a>.</p>

<p>To make it easier, we’ve added <span class="label label--different">different</span> tags to the ones where our style differs.</p>

<h2 id="source-code-layout">Source Code Layout</h2>

<h3 id="utf-encoding">UTF Encoding</h3>

<p>Use <code>UTF-8</code> as the source file encoding</p>

<h3 id="use-soft-tabs">Use soft tabs</h3>

<p>Use two <strong>spaces</strong> per indentation level (aka soft tabs). No hard tabs</p>

<p>```Ruby
# bad - four spaces
def some_method
    do_something
end</p>

<h1 id="good">good</h1>
<p>def some_method
  do_something
end
```</p>

<h3 id="use-unix-style-line-endings">Use Unix-style line endings.</h3>

<p>Use Unix-style line endings. (BSD/Solaris/Linux/OS X users are covered by default, Windows users have to be extra careful.)</p>

<p>If you’re using Git you might want to add the following configuration setting to protect your project from Windows line endings creeping in:</p>

<p><code>bash
$ git config --global core.autocrlf true
</code></p>

<h3 id="dont-use-semicolons">Don’t use semicolons</h3>

<p>Don’t use <code>;</code> to separate statements and expressions. As a corollary - use one expression per line.</p>

<p>```Ruby
# bad
puts ‘foobar’; # superfluous semicolon</p>

<p>puts ‘foo’; puts ‘bar’ # two expressions on the same line</p>

<h1 id="good-1">good</h1>
<p>puts ‘foobar’</p>

<p>puts ‘foo’
puts ‘bar’</p>

<p>puts ‘foo’, ‘bar’ # this applies to puts in particular
```</p>

<h3 id="use-consistent-class-naming-conventions--span-classlabel-label--differentdifferentspan">Use consistent class naming conventions  <span class="label label--different">different</span></h3>

<p>Use the same, typical class definition, even for classes with no body</p>

<p>``` ruby
# wat?!
FooError = Class.new(StandardError)</p>

<h1 id="okish">okish</h1>
<p>class FooError &lt; StandardError; end</p>

<h1 id="best-can-be-more-easily-extended-in-future-and-looks-like-a-class">Best! Can be more easily extended in future and looks like a class</h1>
<p>class FooError &lt; StandardError
end
```</p>

<h3 id="avoid-single-line-methods--span-classlabel-label--differentdifferentspan">Avoid single-line methods  <span class="label label--different">different</span></h3>

<p>Although they are somewhat popular in the wild,
there are a few peculiarities about their definition syntax that make their
use undesirable.</p>

<p>```Ruby
# bad
def too_much; something; something_else; end</p>

<h1 id="y-u-do-dis">Y U DO DIS?!</h1>
<p>def no_braces_method; body end</p>

<h1 id="still-not-ok">Still not OK</h1>
<p>def no_braces_method; body; end</p>

<h1 id="better-but-what-are-you-really-gaining-from-doing-this">Better, but what are you really gaining from doing this?</h1>
<p>def some_method() body end</p>

<h1 id="do-it-like-this">Do it like this!</h1>
<p>def some_method
  body
end
```</p>

<p>This rule also applies to empty-body methods. <span class="label label--different">different</span></p>

<p>```Ruby
# still bad
def no_op; end</p>

<h1 id="good-2">good</h1>
<p>def no_op
end
```</p>

<h3 id="use-spaces-to-make-your-code-more-readable">Use spaces to make your code more readable</h3>

<p>Use spaces around operators, after commas, colons and semicolons, around <code>{</code>
and before <code>}</code>. Whitespace might be (mostly) irrelevant to the Ruby
interpreter, but its proper use is the key to writing easily readable code.</p>

<p><code>Ruby
sum = 1 + 2
a, b = 1, 2
[1, 2, 3].each { |e| puts e }
class FooError &lt; StandardError; end
</code></p>

<p>The only exception, regarding operators, is the exponent operator:</p>

<p>``` Ruby
# bad
e = M * c ** 2</p>

<h1 id="good-3">good</h1>
<p>e = M * c**2
```</p>

<p><code>{</code> and <code>}</code> deserve a bit of clarification, since they are used
for block and hash literals, as well as string interpolation:</p>

<h3 id="for-hash-literals-two-styles-are-considered-acceptable">For hash literals two styles are considered acceptable.</h3>

<p>```Ruby
# good - space after { and before }
{ one: 1, two: 2 }</p>

<h1 id="good---no-space-after--and-before-">good - no space after { and before }</h1>
<p>{one: 1, two: 2}
```</p>

<ul>
  <li>
    <p>The first variant is slightly more readable (and arguably more
popular in the Ruby community in general).</p>
  </li>
  <li>
    <p>The second variant has the advantage of adding visual difference between block and hash
literals. Whichever one you pick - apply it consistently.</p>
  </li>
</ul>

<h3 id="dont-use-spaces-around--or--braces">Don’t use spaces around <code>[</code> or <code>(</code> braces</h3>

<p>Don’t add spaces after <code>(</code>, <code>[</code> or before <code>]</code>, <code>)</code></p>

<p><code>Ruby
some(arg).other
[1, 2, 3].size
</code></p>

<h3 id="no-space-after-">No space after <code>!</code></h3>

<p>This should be self-explanatory</p>

<p>``` Ruby
# bad
! something</p>

<h1 id="good-4">good</h1>
<p>!something
```</p>

<h3 id="no-space-inside-range-literals">No space inside range literals</h3>

<p>```Ruby
# bad
1 .. 3
‘a’ … ‘z’</p>

<h1 id="good-5">good</h1>
<p>1..3
‘a’…‘z’
```</p>

<h3 id="indenting-when-in-case-statements">Indenting <code>when</code> in <code>case</code> statements</h3>

<p>Indent <code>when</code> as deep as <code>case</code> statements. I know that many would disagree
with this one, but it’s the style established in both “The Ruby
Programming Language” and “Programming Ruby”. (Plus it’s how our text editors change it when we auto-tidy our code).</p>

<p>```Ruby
# bad
case
  when song.name == ‘Misty’
    puts ‘Not again!’
  when song.duration &gt; 120
    puts ‘Too long!’
  when Time.now.hour &gt; 21
    puts “It’s too late”
  else
    song.play
end</p>

<h1 id="good-6">good</h1>
<p>case
when song.name == ‘Misty’
  puts ‘Not again!’
when song.duration &gt; 120
  puts ‘Too long!’
when Time.now.hour &gt; 21
  puts “It’s too late”
else
  song.play
end
```</p>

<h3 id="indenting-conditional-assigment">Indenting conditional assigment</h3>

<p>When assigning the result of a conditional expression to a variable, preserve the usual alignment of its branches.</p>

<p>```Ruby
# bad - pretty convoluted
kind = case year
when 1850..1889 then ‘Blues’
when 1890..1909 then ‘Ragtime’
when 1910..1929 then ‘New Orleans Jazz’
when 1930..1939 then ‘Swing’
when 1940..1950 then ‘Bebop’
else ‘Jazz’
end</p>

<p>result = if some_cond
  calc_something
else
  calc_something_else
end</p>

<h1 id="good---its-apparent-whats-going-on">good - it’s apparent what’s going on</h1>
<p>kind = case year
       when 1850..1889 then ‘Blues’
       when 1890..1909 then ‘Ragtime’
       when 1910..1929 then ‘New Orleans Jazz’
       when 1930..1939 then ‘Swing’
       when 1940..1950 then ‘Bebop’
       else ‘Jazz’
       end</p>

<p>result = if some_cond
           calc_something
         else
           calc_something_else
         end</p>

<h1 id="good-and-a-bit-more-width-efficient">good (and a bit more width efficient)</h1>
<p>kind =
  case year
  when 1850..1889 then ‘Blues’
  when 1890..1909 then ‘Ragtime’
  when 1910..1929 then ‘New Orleans Jazz’
  when 1930..1939 then ‘Swing’
  when 1940..1950 then ‘Bebop’
  else ‘Jazz’
  end</p>

<p>result =
  if some_cond
    calc_something
  else
    calc_something_else
  end
```</p>

<h3 id="empty-lines-between-methods--span-classlabel-label--differentdifferentspan">Empty lines between methods  <span class="label label--different">different</span></h3>

<p>Use empty lines between method definitions. Also, where it improves readability, break up a method into logical paragraphs internally. NOTE—Often, where a method <em>can</em> be broken into logical paragraphs, this is hinting at another method which should be extracted.</p>

<p>```Ruby
# This is very simple, it’s fine to not add empty lines between the lines.
def some_method
  data = initialize(options)
  data.manipulate!
  data.result
end</p>

<p>def some_method
  result
end</p>

<h1 id="this-method-is-screaming-to-be-extracted-into-two-smaller-methods">This method is screaming to be extracted into two smaller methods</h1>
<p>def get_daily_comment_names
  comments = Blogit::Comment.order(“created_at”).all</p>

<p># This line should be extracted into a separate method, not just split with an empty line
  comments_sorted_by_day = comments.chunk { |comment| comment.created_at.to_date }</p>

<p>comments_sorted_by_day.map { |day, collection| [day, collection.map(&amp;:name)] }
end</p>

<h1 id="like-this">… like this</h1>
<p>def get_daily_comment_names
  self.comments = Blogit::Comment.order(“created_at”).all
  comments_sorted_by_day.map { |day, collection| [day, collection.map(&amp;:name)] }
end</p>

<p>def comments_sorted_by_day
  comments.chunk { |comment| comment.created_at.to_date }
end</p>

<h1 id="section">:)</h1>

<p>```</p>

<h3 id="avoid-a-comma-after-the-last-paramter">Avoid a comma after the last paramter</h3>

<p>Avoid comma after the last parameter in a method call, especially when the
parameters are not on separate lines.</p>

<p>```Ruby
# bad - easier to move/add/remove parameters, but still not preferred
some_method(
             size,
             count,
             color,
           )</p>

<h1 id="bad">bad</h1>
<p>some_method(size, count, color, )</p>

<h1 id="good-7">good</h1>
<p>some_method(size, count, color)
```</p>

<h3 id="use-spaces-around-equals-in-params">Use spaces around equals in params</h3>

<p>Use spaces around the <code>=</code> operator when assigning default values to method
parameters:</p>

<p>```Ruby
# bad
def some_method(arg1=:default, arg2=nil, arg3=[])
  # do something…
end</p>

<h1 id="good-8">good</h1>
<p>def some_method(arg1 = :default, arg2 = nil, arg3 = [])
  # do something…
end
```</p>

<p>While several Ruby books suggest the first style, the second is much more
prominent in practice (and arguably a bit more readable).</p>

<h3 id="avoiding-line-continuation">Avoiding line continuation</h3>

<p>Avoid line continuation <code>\</code> where not required. In practice, avoid using
line continuations for anything but string concatenation.</p>

<p>```Ruby
# bad
result = 1 - \
         2</p>

<h1 id="good-but-still-ugly-as-hell">good (but still ugly as hell)</h1>
<p>result = 1 \
         - 2</p>

<p>long_string = ‘First part of the long string’ \
              ‘ and second part of the long string’
```</p>

<h3 id="using-line-continuation">Using line continuation</h3>

<p>Use line continuation <code>\</code> when writing a string that’s longer than one line.</p>

<p>``` Ruby
# bad
result = “Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.”</p>

<h1 id="good-9">good</h1>
<p>result = “Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod “ \
           “tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,”\
           “quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo”\
           “consequat.”</p>

<h1 id="also-good">also good</h1>
<p>result = “Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod \
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,\
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.”</p>

<p>```</p>

<h3 id="chaining-methods-across-multiple-lines-span-classlabel-label--differentdifferentspan">Chaining methods across multiple lines <span class="label label--different">different</span></h3>

<p>When continuing a chained method invocation on another line, include the <code>.</code> on the first line to indicate that the expression continues on the next.</p>

<p>Indent the next line two spaces so that it’s clear the code follows on from something.</p>

<p>```Ruby
# Do this
one.two.three.
  four</p>

<h1 id="dont-do-this">Don’t do this</h1>
<p>one.two.three
  .four
```</p>

<p>This is a hotly debated issue. Both styles below have their merit, but <a href="//katanacode.com">Katana Code</a> has decided on the first style.</p>

<h3 id="align-parameters-spanning-more-than-one-line">Align parameters spanning more than one line</h3>

<p>Align the parameters of a method call if they span more than one
  line. When aligning parameters is not appropriate due to line-length
  constraints, single indent for the lines after the first is also
  acceptable.</p>

<p>```Ruby
  # starting point (line is too long)
  def send_mail(source)
    Mailer.deliver(to: ‘bob@example.com’, from: ‘us@example.com’, subject: ‘Important message’, body: source.text)
  end</p>

<p># bad (double indent)
  def send_mail(source)
    Mailer.deliver(
        to: ‘bob@example.com’,
        from: ‘us@example.com’,
        subject: ‘Important message’,
        body: source.text)
  end</p>

<p># good
  def send_mail(source)
    Mailer.deliver(to: ‘bob@example.com’,
                   from: ‘us@example.com’,
                   subject: ‘Important message’,
                   body: source.text)
  end</p>

<p># good (normal indent)
  def send_mail(source)
    Mailer.deliver(
      to: ‘bob@example.com’,
      from: ‘us@example.com’,
      subject: ‘Important message’,
      body: source.text
    )
  end
  ```</p>

<h3 id="aligning-array-elements">Aligning Array elements</h3>

<p>Align the elements of array literals spanning multiple lines.</p>

<p>```Ruby
# bad - single indent
menu_item = [‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’,
  ‘Baked beans’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’]</p>

<h1 id="good-10">good</h1>
<p>menu_item = [
  ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’,
  ‘Baked beans’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’
]</p>

<h1 id="good-11">good</h1>
<p>menu_item =
  [‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’,
   ‘Baked beans’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’, ‘Spam’]
```</p>

<h3 id="use-underscores-with-large-numbers">Use underscores with large numbers</h3>

<p>Add underscores to large numeric literals to improve their readability.</p>

<p>```Ruby
# bad - how many 0s are there?
num = 1000000</p>

<h1 id="good---much-easier-to-parse-for-the-human-brain">good - much easier to parse for the human brain</h1>
<p>num = 1_000_000
```</p>

<h3 id="document-with-tomdoc-span-classlabel-label--differentdifferentspan">Document with TomDoc <span class="label label--different">different</span></h3>

<p>Use <a href="http://TomDoc.org">TomDoc</a> and its conventions for API documentation.</p>

<p>Stick to TomDoc’s guidelines</p>

<h3 id="use-a-wrap-column-span-classlabel-label--differentdifferentspan">Use a wrap column <span class="label label--different">different</span></h3>

<p>Limit lines to <strong>90 characters</strong>.</p>

<h3 id="avoid-trailing-whitespace">Avoid trailing whitespace</h3>

<p>Where possible, avoid trailing whitespace.</p>

<h3 id="avoid-new-lines-at-the-end-of-files">Avoid new lines at the end of files</h3>

<p>If possible, set up your text-editor to add these.</p>

<h3 id="avoid-block-comments">Avoid block comments</h3>

<p>Don’t use block comments. They cannot be preceded by whitespace and are not
as easy to spot as regular comments.</p>

<p>```Ruby
# bad
=begin
comment line
another comment line
=end</p>

<h1 id="good-12">good</h1>
<p># comment line
# another comment line
```</p>

<h2 id="syntax">Syntax</h2>

<h3 id="dont-use--for-methods">Don’t use <code>::</code> for methods</h3>

<p>Use <code>::</code> only to reference constants(this includes classes and
modules) and constructors (like <code>Array()</code> or <code>Nokogiri::HTML()</code>).</p>

<p>Do not use <code>::</code> for regular method invocation.</p>

<p>```Ruby
# bad
SomeClass::some_method
some_object::some_method</p>

<h1 id="good-13">good</h1>
<p>SomeClass.some_method
some_object.some_method
SomeModule::SomeClass::SOME_CONST
SomeModule::SomeClass()
```</p>

<h3 id="omit-parenthesis-when-there-are-no-params">Omit parenthesis when there are no params</h3>

<p>Use <code>def</code> with parentheses when there are parameters. Omit the
parentheses when the method doesn’t accept any parameters.</p>

<p>```Ruby
# bad
def some_method()
 # body omitted
end</p>

<h1 id="good-14">good</h1>
<p>def some_method
 # body omitted
end</p>

<h1 id="bad-1">bad</h1>
<p>def some_method_with_parameters param1, param2
 # body omitted
end</p>

<h1 id="good-15">good</h1>
<p>def some_method_with_parameters(param1, param2)
 # body omitted
end
```</p>

<h3 id="avoid-parallel-assignment">Avoid parallel assignment</h3>

<p>Avoid the use of parallel assignment for defining variables. It’s fun, but also harder to read and maintain.</p>

<p>Parallel assignment is allowed when it is the return of a method call, used with
the splat operator, or when used to swap variable assignment.</p>

<p>Parallel assignment is less readable than separate assignment. It is also slightly
slower than separate assignment.</p>

<p>```Ruby
# bad
a, b, c, d = ‘foo’, ‘bar’, ‘baz’, ‘foobar’</p>

<h1 id="good-16">good</h1>
<p>a = ‘foo’
b = ‘bar’
c = ‘baz’
d = ‘foobar’</p>

<h1 id="good---swapping-variable-assignment">good - swapping variable assignment</h1>
<p># Swapping variable assignment is a special case because it will allow you to
# swap the values that are assigned to each variable.
a = ‘foo’
b = ‘bar’</p>

<p>a, b = b, a
puts a # =&gt; ‘bar’
puts b # =&gt; ‘foo’</p>

<h1 id="good---method-return">good - method return</h1>
<p>def multi_return
  [1, 2]
end</p>

<p>first, second = multi_return</p>

<h1 id="good---use-with-splat">good - use with splat</h1>
<p>first, *list = [1,2,3,4]</p>

<p>hello_array = *“Hello”</p>

<p>a = *(1..3)
```</p>

<h3 id="use-for-loops-selectively">Use <code>for</code> loops selectively</h3>

<p>Do not use <code>for</code>, unless you know exactly why. Most of the time iterators
should be used instead. <code>for</code> is implemented in terms of <code>each</code> (so
you’re adding a level of indirection), but with a twist - <code>for</code>
doesn’t introduce a new scope (unlike <code>each</code>) and variables defined
in its block will be visible outside it.</p>

<p>```Ruby
arr = [1, 2, 3]</p>

<h1 id="bad-2">bad</h1>
<p>for elem in arr do
  puts elem
end</p>

<h1 id="note-that-elem-is-accessible-outside-of-the-for-loop">note that elem is accessible outside of the for loop</h1>
<p>elem # =&gt; 3</p>

<h1 id="good-17">good</h1>
<p>arr.each { |elem| puts elem }</p>

<h1 id="elem-is-not-accessible-outside-eachs-block">elem is not accessible outside each’s block</h1>
<p>elem # =&gt; NameError: undefined local variable or method <code>elem'
</code>``</p>

<h3 id="avoid-then-in-conditionals">Avoid <code>then</code> in conditionals</h3>

<p>Do not use <code>then</code> for multi-line <code>if/unless</code>.</p>

<p>```Ruby
# bad
if some_condition then
  # body omitted
end</p>

<h1 id="good-18">good</h1>
<p>if some_condition
  # body omitted
end
```</p>

<h3 id="keep-the-condition-on-the-same-line">Keep the condition on the same line</h3>

<p>Always put the condition on the same line as the <code>if</code>/<code>unless</code> in a
  multi-line conditional.</p>

<p>```Ruby
# bad - who would do this?!
if
  some_condition
  do_something
  do_something_else
end</p>

<h1 id="good-19">good</h1>
<p>if some_condition
  do_something
  do_something_else
end
```</p>

<h3 id="use-the-ternary-for-short-conditions-span-classlabel-label--differentdifferentspan">Use the ternary for short conditions <span class="label label--different">different</span></h3>

<p>Favour the ternary operator(<code>?:</code>) over <code>if/then/else/end</code> constructs. It’s more common and obviously more concise.</p>

<p>```Ruby
# bad
result = if some_condition then something else something_else end</p>

<h1 id="good-20">good</h1>
<p>result = some_condition ? something : something_else</p>

<h1 id="bad-3">bad</h1>
<p>result = if some_condition; something else something_else end</p>

<h1 id="good-21">good</h1>
<p>result = some_condition ? something : something_else</p>

<p>```</p>

<h3 id="use-ifelse-elsewhere">Use if/else elsewhere</h3>

<p>Use one expression per branch in a ternary operator. This
  also means that ternary operators must not be nested. Prefer
  <code>if/else</code> constructs in these cases.</p>

<p>```Ruby
# bad
some_condition ? (nested_condition ? nested_something : nested_something_else) : something_else</p>

<h1 id="good-22">good</h1>
<p>if some_condition
  nested_condition ? nested_something : nested_something_else
else
  something_else
end
```</p>

<h3 id="keep-conditional-branches-as-clear-as-possible-span-classlabel-label--differentdifferentspan">Keep conditional branches as clear as possible <span class="label label--different">different</span></h3>

<p>Conditional branches should be as easy as possible to read. Sometimes that means repeating the name of a variable in each branch.</p>

<p>This is also easier to extend in future with multiple variable assignments, without the need to reshape this expression.</p>

<p>```Ruby
# bad
result =
  if condition
    x
  else
    y
  end</p>

<h1 id="good-23">good</h1>
<p>if condition
  result = x
else
  result = y
end
```</p>

<h3 id="use-when-with-then">Use <code>when</code> with <code>then</code></h3>

<p>Use <code>when x then ...</code> for one-line cases. The alternative syntax <code>when x:
  ...</code> has been removed as of Ruby 1.9.</p>

<h3 id="avoid-when">Avoid <code>when;</code></h3>

<p>Do not use <code>when x; ...</code>. See the previous rule.</p>

<h3 id="use--instead-of-not">Use <code>!</code> instead of <code>not</code></h3>

<p>```Ruby
# bad - braces are required because of op precedence
x = (not something)</p>

<h1 id="good-24">good</h1>
<p>x = !something
```</p>

<h3 id="use---when-required-span-classlabel-label--differentdifferentspan">Use  <code>!!</code> when required <span class="label label--different">different</span></h3>

<p>The double–bang operator is a quick and efficient way to convert a non-boolean
  value into it’s boolean equivalent. This is useful when a method contract specifically  expects a boolean value to be returned.</p>

<p>Double-bangs are cheaper than using <code>nil?</code> or <code>blank?</code> etc. because fewer method calls are required.</p>

<p>```Ruby
# good
x = ‘test’
# obscure nil check
if !!x
  # body omitted
end</p>

<p>x = false
# double negation is useless on booleans
!!x # =&gt; false</p>

<h1 id="bad---this-is-more-method-calls-and-more-hassle">bad - this is more method calls, and more hassle.</h1>
<p>x = ‘test’
unless x.nil?
  # body omitted
end</p>

<h1 id="better-alternative">better alternative</h1>
<p>x = ‘test’
# obscure nil check
unless !x
  # body omitted
end
```</p>

<h3 id="avoid-using-and-and-or-">Avoid using <code>and</code> and <code>or</code> :(</h3>

<p>The <code>and</code> and <code>or</code> keywords are banned. It’s just not worth it. Always use
<code>&amp;&amp;</code> and <code>||</code> instead.</p>

<p><code>&amp;&amp;</code> is a character shorter than <code>and</code> — woop! #gains</p>

<p>Apart from that, <code>and</code> and <code>or</code> cannot be used within <code>where</code> statements
  (among other places), meaning you either have to choose one style, or mix the two.</p>

<p>We choose one style.</p>

<p>```Ruby
# bad
# boolean expression
if some_condition and some_other_condition
  do_something
end</p>

<h1 id="control-flow">control flow</h1>
<p>document.saved? or document.save!</p>

<h1 id="good-25">good</h1>
<p># boolean expression
if some_condition &amp;&amp; some_other_condition
  do_something
end</p>

<h1 id="control-flow-1">control flow</h1>
<p>document.saved? || document.save!
```</p>

<h3 id="avoid-using--on-multi-lines">Avoid using <code>?</code> on multi-lines</h3>

<p>Avoid multi-line <code>?:</code> (the ternary operator); use <code>if/unless</code> instead.</p>

<h3 id="favour-modifier-ifelse">Favour modifier <code>if/else</code></h3>

<p>Favour modifier <code>if/unless</code> usage when you have a single-line body. Another
good alternative is the usage of control flow <code>&amp;&amp;/||</code>.</p>

<p>```Ruby
# bad
if some_condition
  do_something
end</p>

<h1 id="good-26">good</h1>
<p>do_something if some_condition</p>

<h1 id="this-is-a-terrible-option">this is a terrible option</h1>
<p>some_condition &amp;&amp; do_something
```</p>

<h3 id="avoid-using-ifelse-for-block-execution">Avoid using if/else for block execution</h3>

<p>Avoid modifier <code>if/unless</code> usage at the end of a non-trivial multi-line
block.</p>

<p>```Ruby
# bad
10.times do
  # multi-line body omitted
end if some_condition</p>

<h1 id="good-27">good</h1>
<p>if some_condition
  10.times do
    # multi-line body omitted
  end
end</p>

<h1 id="best---extract-the-block-to-a-method-if-possible">best - extract the block to a method if possible</h1>
<p>def do_10_times_thing
  10.times do
    # multi-line body omitted
  end
end</p>

<p>do_10_times_thing if some_condition
```</p>

<h3 id="favour-unless-over-if">Favour <code>unless</code> over <code>if</code></h3>

<p>Favour <code>unless</code> over <code>if</code> for negative conditions (or control flow <code>||</code>).</p>

<p>```Ruby
# bad
do_something if !some_condition</p>

<h1 id="bad-4">bad</h1>
<p>do_something if not some_condition</p>

<h1 id="good-28">good</h1>
<p>do_something unless some_condition</p>

<h1 id="another-good-option">another good option</h1>
<p>some_condition || do_something
```</p>

<h3 id="do-not-use-unless-with-else">Do not use <code>unless</code> with <code>else</code></h3>

<p>Do not use <code>unless</code> with <code>else</code>. Rewrite these with the positive case first.</p>

<p>```Ruby
# bad
unless success?
  puts ‘failure’
else
  puts ‘success’
end</p>

<h1 id="good-29">good</h1>
<p>if success?
  puts ‘success’
else
  puts ‘failure’
end
```</p>

<h3 id="dont-use-parentheses-around-conditions">Don’t use parentheses around conditions</h3>

<p>Don’t use parentheses around the condition of an <code>if/unless/while/until</code>.</p>

<p>```Ruby
# bad
if (x &gt; 10)
  # body omitted
end</p>

<h1 id="good-30">good</h1>
<p>if x &gt; 10
  # body omitted
end
```</p>

<p>Note that there is an exception to this rule, namely <a href="#safe-assignment-in-condition">safe assignment in
condition</a>.</p>

<h3 id="dont-use-do-for-whileuntil">Don’t use <code>do</code> for <code>while/until</code></h3>

<p>Do not use <code>while/until condition do</code> for multi-line <code>while/until</code>.</p>

<p>```Ruby
# bad
while x &gt; 5 do
  # body omitted
end</p>

<p>until x &gt; 5 do
  # body omitted
end</p>

<h1 id="good-31">good</h1>
<p>while x &gt; 5
  # body omitted
end</p>

<p>until x &gt; 5
  # body omitted
end
```</p>

<h3 id="favour-modifier-whileuntil-when-a-single-body">Favour modifier <code>while/until</code> when a single body</h3>

<p>Favour modifier <code>while/until</code> usage when you have a single-line body.</p>

<p>```Ruby
# bad
while some_condition
  do_something
end</p>

<h1 id="good-32">good</h1>
<p>do_something while some_condition
```</p>

<h4 id="favour-until-over-while-for-negative-conditions">Favour <code>until</code> over <code>while</code> for negative conditions.</h4>

<p>```Ruby
# bad
do_something while !some_condition</p>

<h1 id="good-33">good</h1>
<p>do_something until some_condition
```</p>

<h3 id="for-infinite-loops">For infinite loops</h3>

<p>Use <code>Kernel#loop</code> instead of <code>while/until</code> when you need an infinite loop.</p>

<p>```ruby
# bad
while true
  do_something
end</p>

<p>until false
  do_something
end</p>

<h1 id="good-34">good</h1>
<p>loop do
  do_something
end
```</p>

<h3 id="looping-until-a-value">Looping until a value</h3>

<p>Use <code>Kernel#loop</code> with <code>break</code> rather than <code>begin/end/until</code> or
<code>begin/end/while</code> for post-loop tests.</p>

<p>```Ruby
# bad
begin
  puts val
  val += 1
end while val &lt; 0</p>

<h1 id="good-35">good</h1>
<p>loop do
  puts val
  val += 1
  break unless val &lt; 0
end
```</p>

<h3 id="skip-parenthesis-on-dsl-methods">Skip parenthesis on DSL methods</h3>

<p>Omit parentheses around parameters for methods that are part of an internal
DSL (e.g. Rake, Rails, RSpec), methods that have “keyword” status in Ruby
(e.g. <code>attr_reader</code>, <code>puts</code>) and attribute access methods. Use parentheses
around the arguments of all other method invocations.</p>

<p>```Ruby
class Person
  attr_reader :name, :age</p>

<p># omitted
end</p>

<p>temperance = Person.new(‘Temperance’, 30)
temperance.name</p>

<p>puts temperance.age</p>

<p>x = Math.sin(y)
array.delete(e)</p>

<p>bowling.score.should == 0
```</p>

<h3 id="omit-braces-around-options-hashes">Omit braces around options Hashes</h3>

<p>Omit the outer braces around an implicit options hash.</p>

<p>```Ruby
# bad
user.set({ name: ‘John’, age: 45, permissions: { read: true } })</p>

<h1 id="good-36">good</h1>
<p>user.set(name: ‘John’, age: 45, permissions: { read: true })
```</p>

<h3 id="omit-braces-around-dsl-options-hashes">Omit braces around DSL options Hashes</h3>

<p>Omit both the outer braces and parentheses for methods that are part of an
internal DSL.</p>

<p>```Ruby
class Person &lt; ActiveRecord::Base
  # bad
  validates(:name, { presence: true, length: { within: 1..10 } })</p>

<p># good
  validates :name, presence: true, length: { within: 1..10 }
end
```</p>

<h3 id="omit-parentheses-for-methods-with-no-args">Omit parentheses for methods with no args.</h3>

<p>Omit parentheses for method calls with no arguments.</p>

<p>```Ruby
# bad
Kernel.exit!()
2.even?()
fork()
‘test’.upcase()</p>

<h1 id="good-37">good</h1>
<p>Kernel.exit!
2.even?
fork
‘test’.upcase
```</p>

<h3 id="single-method-blocks">Single-method blocks</h3>

<p>Use the proc invocation shorthand when the invoked method is the only operation of a block.</p>

<p>```Ruby
# bad
names.map { |name| name.upcase }</p>

<h1 id="good-38">good</h1>
<p>names.map(&amp;:upcase)
```</p>

<h3 id="single-line-blocks">Single line blocks</h3>

<p>Prefer <code>{...}</code> over <code>do...end</code> for single-line blocks.  Avoid using <code>{...}</code>
for multi-line blocks (multiline chaining is always ugly). Always use
<code>do...end</code> for “control flow” and “method definitions” (e.g. in Rakefiles and
certain DSLs).  Avoid <code>do...end</code> when chaining.</p>

<p>```Ruby
names = %w(Bozhidar Steve Sarah)</p>

<h1 id="bad-5">bad</h1>
<p>names.each do |name|
  puts name
end</p>

<h1 id="good-39">good</h1>
<p>names.each { |name| puts name }</p>

<h1 id="bad-6">bad</h1>
<p>names.select do |name|
  name.start_with?(‘S’)
end.map { |name| name.upcase }</p>

<h1 id="good-40">good</h1>
<p>names.select { |name| name.start_with?(‘S’) }.map(&amp;:upcase)
```</p>

<p>Some will argue that multiline chaining would look OK with the use of {…},
but they should ask themselves - is this code really readable and can the
blocks’ contents be extracted into nifty methods?</p>

<h3 id="block-arguments">Block arguments</h3>

<p>Consider using explicit block argument to avoid writing block literal that
just passes its arguments to another block. Beware of the performance impact,
though, as the block gets converted to a Proc.</p>

<p>```Ruby
require ‘tempfile’</p>

<h1 id="bad-7">bad</h1>
<p>def with_tmp_dir
  Dir.mktmpdir do |tmp_dir|
    Dir.chdir(tmp_dir) { |dir| yield dir }  # block just passes arguments
  end
end</p>

<h1 id="good-41">good</h1>
<p>def with_tmp_dir(&amp;block)
  Dir.mktmpdir do |tmp_dir|
    Dir.chdir(tmp_dir, &amp;block)
  end
end</p>

<p>with_tmp_dir do |dir|
  puts “dir is accessible as a parameter and pwd is set: #{dir}”
end
```</p>

<h3 id="avoid-explicit-return">Avoid explicit <code>return</code></h3>

<p>Avoid <code>return</code> where not required for flow of control. Even though this is faster, it’s more code to manage and is arguably little less readable.</p>

<p>```Ruby
# bad
def some_method(some_arr)
  return some_arr.size
end</p>

<h1 id="good-42">good</h1>
<p>def some_method(some_arr)
  some_arr.size
end
```</p>

<h3 id="avoid-self-unless-required">Avoid <code>self</code> unless required</h3>

<p>Avoid <code>self</code> where not required. (It is only required when calling a self
write accessor.)</p>

<p>```Ruby
# bad
def ready?
  if self.last_reviewed_at &gt; self.last_updated_at
    self.worker.update(self.content, self.options)
    self.status = :in_progress
  end
  self.status == :verified
end</p>

<h1 id="good-43">good</h1>
<p>def ready?
  if last_reviewed_at &gt; last_updated_at
    worker.update(content, options)
    self.status = :in_progress
  end
  status == :verified
end
```</p>

<h3 id="dont-shadow-methods-with-vars">Don’t shadow methods with vars</h3>

<p>As a corollary, avoid shadowing methods with local variables unless they are
both equivalent.</p>

<p>```Ruby
class Foo
  attr_accessor :options</p>

<p># ok
  def initialize(options)
    self.options = options
    # both options and self.options are equivalent here
  end</p>

<p># bad
  def do_something(options = {})
    unless options[:when] == :later
      output(self.options[:message])
    end
  end</p>

<p># good
  def do_something(params = {})
    unless params[:when] == :later
      output(options[:message])
    end
  end</p>

<p># also good
  def do_something(_options = {})
    unless _options[:when] == :later
      output(_options[:message])
    end
  end
end
```</p>

<h3 id="assignment-in-conditionals">Assignment in conditionals</h3>

<p>Don’t use the return value of <code>=</code> (an assignment) in conditional expressions
unless the assignment is wrapped in parentheses. This is a fairly popular
idiom among Rubyists that’s sometimes referred to as <em>safe assignment in
condition</em>.</p>

<p>```Ruby
# bad (+ a warning)
if v = array.grep(/foo/)
  do_something(v)
  …
end</p>

<h1 id="good-mri-would-still-complain-but-rubocop-wont">good (MRI would still complain, but RuboCop won’t)</h1>
<p>if (v = array.grep(/foo/))
  do_something(v)
  …
end</p>

<h1 id="good-44">good</h1>
<p>v = array.grep(/foo/)
if v
  do_something(v)
  …
end
```</p>

<h3 id="use-shorthand-operators">Use shorthand operators</h3>

<p>Use shorthand self assignment operators whenever applicable.</p>

<p>```Ruby
# bad
x = x + y
x = x * y
x = x**y
x = x / y
x = x || y
x = x &amp;&amp; y</p>

<h1 id="good-45">good</h1>
<p>x += y
x *= y
x **= y
x /= y
x ||= y
x &amp;&amp;= y
```</p>

<h3 id="use-double-pipes-for-defaults">Use double-pipes for defaults</h3>

<p>Use <code>||=</code> to initialize variables only if they’re not already initialized.</p>

<p>```Ruby
# bad
name = name ? name : ‘Bozhidar’</p>

<h1 id="bad-8">bad</h1>
<p>name = ‘Bozhidar’ unless name</p>

<h1 id="good---set-name-to-bozhidar-only-if-its-nil-or-false">good - set name to Bozhidar, only if it’s nil or false</h1>
<p>name ||= ‘Bozhidar’
```</p>

<h3 id="dont-use-double-pipes-for-bools">Don’t use double-pipes for bools</h3>

<p>Don’t use <code>||=</code> to initialize boolean variables. (Consider what would happen
if the current value happened to be <code>false</code>.)</p>

<p>```Ruby
# bad - would set enabled to true even if it was false
enabled ||= true</p>

<h1 id="good-46">good</h1>
<p>enabled = true if enabled.nil?
```</p>

<h3 id="use-double-amps-to-check-for-existence">Use double-amps to check for existence</h3>

<p>Use <code>&amp;&amp;=</code> to preprocess variables that may or may not exist. Using <code>&amp;&amp;=</code>
will change the value only if it exists, removing the need to check its
existence with <code>if</code>.</p>

<p>```Ruby
# bad
if something
  something = something.downcase
end</p>

<h1 id="bad-9">bad</h1>
<p>something = something ? something.downcase : nil</p>

<h1 id="ok">ok</h1>
<p>something = something.downcase if something</p>

<h1 id="good-47">good</h1>
<p>something = something &amp;&amp; something.downcase</p>

<h1 id="better">better</h1>
<p>something &amp;&amp;= something.downcase
```</p>

<h3 id="avoid--outside-of-case">Avoid <code>===</code> outside of <code>case</code></h3>

<p>Avoid explicit use of the case equality operator <code>===</code>. As its name implies
it is meant to be used implicitly by <code>case</code> expressions and outside of them it
yields some pretty confusing code.</p>

<p>```Ruby
# bad
Array === something
(1..100) === 7
/something/ === some_string</p>

<h1 id="good-48">good</h1>
<p>something.is_a?(Array)
(1..100).include?(7)
some_string =~ /something/
```</p>

<h3 id="use--not-eql">Use <code>==</code>, not <code>eql?</code></h3>

<p>Do not use <code>eql?</code> when using <code>==</code> will do. The stricter comparison semantics
provided by <code>eql?</code> are rarely needed in practice.</p>

<p>```Ruby
# bad - eql? is the same as == for strings
“ruby”.eql? some_str</p>

<h1 id="good-49">good</h1>
<p>“ruby” == some_str
1.0.eql? x # eql? makes sense here if want to differentiate between Fixnum and Float 1
```</p>

<h3 id="avoid-cryptic-perl-isms">Avoid cryptic Perl-isms</h3>

<p>Avoid using Perl-style special variables (like <code>$:</code>, <code>$;</code>, etc. ). They are
quite cryptic and their use in anything but one-liner scripts is discouraged.
Use the human-friendly aliases provided by the <code>English</code> library.</p>

<p>```Ruby
# bad
$:.unshift File.dirname(<strong>FILE</strong>)</p>

<h1 id="good-50">good</h1>
<p>require ‘English’
$LOAD_PATH.unshift File.dirname(<strong>FILE</strong>)
```</p>

<h3 id="no-spaces-before-parenthesis">No spaces before parenthesis</h3>

<p>Do not put a space between a method name and the opening parenthesis.</p>

<p>```Ruby
# bad
f (3 + 2) + 1</p>

<h1 id="good-51">good</h1>
<p>f(3 + 2) + 1
```</p>

<h3 id="parenthesis-in-arguments">Parenthesis in arguments</h3>

<p>If the first argument to a method begins with an open parenthesis, always
use parentheses in the method invocation. For example, write <code>f((3 + 2) + 1)</code>.</p>

<h3 id="always-warn-at-runtime">Always warn at runtime</h3>

<p>Always run the Ruby interpreter with the <code>-w</code> option so it will warn you if
you forget either of the rules above!</p>

<ul>
  <li>
    <p><a name="no-nested-methods"></a>
Do not use nested method definitions, use lambda instead.
Nested method definitions actually produce methods in the same scope
(e.g. class) as the outer method. Furthermore, the “nested method” will be
redefined every time the method containing its definition is invoked.</p>

    <p>```Ruby
# bad
def foo(x)
  def bar(y)
    # body omitted
  end</p>

    <p>bar(x)
end</p>

    <h1 id="good---the-same-as-the-previous-but-no-bar-redefinition-on-every-foo-call">good - the same as the previous, but no bar redefinition on every foo call</h1>
    <p>def bar(y)
  # body omitted
end</p>

    <p>def foo(x)
  bar(x)
end</p>

    <h1 id="also-good-1">also good</h1>
    <p>def foo(x)
  bar = -&gt;(y) { … }
  bar.call(x)
end
```</p>
  </li>
  <li>
    <p><a name="lambda-multi-line"></a>
Use the new lambda literal syntax for single line body blocks. Use the
<code>lambda</code> method for multi-line blocks.</p>

    <p>```Ruby
# bad
l = lambda { |a, b| a + b }
l.call(1, 2)</p>

    <h1 id="correct-but-looks-extremely-awkward">correct, but looks extremely awkward</h1>
    <p>l = -&gt;(a, b) do
  tmp = a * 7
  tmp * b / 50
end</p>

    <h1 id="good-52">good</h1>
    <p>l = -&gt;(a, b) { a + b }
l.call(1, 2)</p>

    <p>l = lambda do |a, b|
  tmp = a * 7
  tmp * b / 50
end
```</p>
  </li>
  <li>
    <p><a name="stabby-lambda-no-args"></a>
Omit the parameter parentheses when defining a stabby lambda with
no parameters.</p>

    <p>```Ruby
# bad
l = -&gt;() { something }</p>

    <h1 id="good-53">good</h1>
    <p>l = -&gt; { something }
```</p>
  </li>
  <li>
    <p><a name="proc"></a>
Prefer <code>proc</code> over <code>Proc.new</code>.</p>

    <p>```Ruby
# bad
p = Proc.new { |n| puts n }</p>

    <h1 id="good-54">good</h1>
    <p>p = proc { |n| puts n }
```</p>
  </li>
  <li>
    <p><a name="proc-call"></a>
Prefer <code>proc.call()</code> over <code>proc[]</code> or <code>proc.()</code> for both lambdas and procs.</p>

    <p>```Ruby
# bad - looks similar to Enumeration access
l = -&gt;(v) { puts v }
l[1]</p>

    <h1 id="also-bad---uncommon-syntax">also bad - uncommon syntax</h1>
    <p>l = -&gt;(v) { puts v }
l.(1)</p>

    <h1 id="good-55">good</h1>
    <p>l = -&gt;(v) { puts v }
l.call(1)
```</p>
  </li>
  <li>
    <p><a name="underscore-unused-vars"></a>
Prefix with <code>_</code> unused block parameters and local variables. It’s also
acceptable to use just <code>_</code> (although it’s a bit less descriptive). This
convention is recognized by the Ruby interpreter and tools like RuboCop and
will suppress their unused variable warnings.</p>

    <p>```Ruby
# bad
result = hash.map { |k, v| v + 1 }</p>

    <p>def something(x)
  unused_var, used_var = something_else(x)
  # …
end</p>

    <h1 id="good-56">good</h1>
    <p>result = hash.map { |_k, v| v + 1 }</p>

    <p>def something(x)
  _unused_var, used_var = something_else(x)
  # …
end</p>

    <h1 id="good-57">good</h1>
    <p>result = hash.map { |_, v| v + 1 }</p>

    <p>def something(x)
  _, used_var = something_else(x)
  # …
end
```</p>
  </li>
  <li>
    <p><a name="global-stdout"></a>
Use <code>$stdout/$stderr/$stdin</code> instead of <code>STDOUT/STDERR/STDIN</code>.
<code>STDOUT/STDERR/STDIN</code> are constants, and while you can actually reassign
(possibly to redirect some stream) constants in Ruby, you’ll get an
interpreter warning if you do so.</p>
  </li>
  <li>
    <p><a name="warn"></a>
Use <code>warn</code> instead of <code>$stderr.puts</code>. Apart from being more concise and
clear, <code>warn</code> allows you to suppress warnings if you need to (by setting the
warn level to 0 via <code>-W0</code>).</p>
  </li>
  <li>
    <p><a name="sprintf"></a>
Favour the use of <code>sprintf</code> and its alias <code>format</code> over the fairly cryptic
<code>String#%</code> method.</p>

    <p>```Ruby
# bad
‘%d %d’ % [20, 10]
# =&gt; ‘20 10’</p>

    <h1 id="good-58">good</h1>
    <p>sprintf(‘%d %d’, 20, 10)
# =&gt; ‘20 10’</p>

    <h1 id="good-59">good</h1>
    <p>sprintf(‘%{first} %{second}’, first: 20, second: 10)
# =&gt; ‘20 10’</p>

    <p>format(‘%d %d’, 20, 10)
# =&gt; ‘20 10’</p>

    <h1 id="good-60">good</h1>
    <p>format(‘%{first} %{second}’, first: 20, second: 10)
# =&gt; ‘20 10’
```</p>
  </li>
  <li>
    <p><a name="array-join"></a>
Favour the use of <code>Array#join</code> over the fairly cryptic <code>Array#*</code> with</p>

    <p>a string argument.</p>

    <p>```Ruby
# bad
%w(one two three) * ‘, ‘
# =&gt; ‘one, two, three’</p>

    <h1 id="good-61">good</h1>
    <p>%w(one two three).join(‘, ‘)
# =&gt; ‘one, two, three’
```</p>
  </li>
  <li>
    <p><a name="splat-arrays"></a>
Use <code>[*var]</code> or <code>Array()</code> instead of explicit <code>Array</code> check, when dealing
with a variable you want to treat as an Array, but you’re not certain it’s an
array.</p>

    <p>```Ruby
# bad
paths = [paths] unless paths.is_a? Array
paths.each { |path| do_something(path) }</p>

    <h1 id="good-62">good</h1>
    <p>[*paths].each { |path| do_something(path) }</p>

    <h1 id="good-and-a-bit-more-readable">good (and a bit more readable)</h1>
    <p>Array(paths).each { |path| do_something(path) }
```</p>
  </li>
  <li>
    <p><a name="ranges-or-between"></a>
Use ranges or <code>Comparable#between?</code> instead of complex comparison logic when
possible.</p>

    <p>```Ruby
# bad
do_something if x &gt;= 1000 &amp;&amp; x &lt;= 2000</p>

    <h1 id="good-63">good</h1>
    <p>do_something if (1000..2000).include?(x)</p>

    <h1 id="good-64">good</h1>
    <p>do_something if x.between?(1000, 2000)
```</p>
  </li>
  <li>
    <p><a name="predicate-methods"></a>
Favour the use of predicate methods to explicit comparisons with <code>==</code>.
Numeric comparisons are OK.</p>

    <p>```Ruby
# bad
if x % 2 == 0
end</p>

    <p>if x % 2 == 1
end</p>

    <p>if x == nil
end</p>

    <h1 id="good-65">good</h1>
    <p>if x.even?
end</p>

    <p>if x.odd?
end</p>

    <p>if x.nil?
end</p>

    <p>if x.zero?
end</p>

    <p>if x == 0
end
```</p>
  </li>
  <li>
    <p><a name="no-non-nil-checks"></a>
Don’t do explicit non-<code>nil</code> checks unless you’re dealing with boolean
values.</p>

    <p>```ruby
  # bad
  do_something if !something.nil?
  do_something if something != nil</p>

    <p># good
  do_something if something</p>

    <p># good - dealing with a boolean
  def value_set?
    !@some_boolean.nil?
  end
  ```</p>
  </li>
  <li>
    <p><a name="no-BEGIN-blocks"></a>
Avoid the use of <code>BEGIN</code> blocks.</p>
  </li>
  <li>
    <p><a name="no-END-blocks"></a>
Do not use <code>END</code> blocks. Use <code>Kernel#at_exit</code> instead.</p>

    <p>```ruby
# bad
END { puts ‘Goodbye!’ }</p>

    <h1 id="good-66">good</h1>
    <p>at_exit { puts ‘Goodbye!’ }
```</p>
  </li>
  <li>
    <p><a name="no-flip-flops"></a>
Avoid the use of flip-flops.</p>
  </li>
  <li>
    <p><a name="no-nested-conditionals"></a>
Avoid use of nested conditionals for flow of control.</p>

    <p>Prefer a guard clause when you can assert invalid data. A guard clause
is a conditional statement at the top of a function that bails out as
soon as it can.</p>

    <p>```Ruby
# bad
def compute_thing(thing)
  if thing[:foo]
    update_with_bar(thing)
    if thing[:foo][:bar]
      partial_compute(thing)
    else
      re_compute(thing)
    end
  end
end</p>

    <h1 id="good-67">good</h1>
    <p>def compute_thing(thing)
  return unless thing[:foo]
  update_with_bar(thing[:foo])
  return re_compute(thing) unless thing[:foo][:bar]
  partial_compute(thing)
end
```</p>

    <p>Prefer <code>next</code> in loops instead of conditional blocks.</p>

    <p>```Ruby
# bad
[0, 1, 2, 3].each do |item|
  if item &gt; 1
    puts item
  end
end</p>

    <h1 id="good-68">good</h1>
    <p>[0, 1, 2, 3].each do |item|
  next unless item &gt; 1
  puts item
end
```</p>
  </li>
  <li>
    <p><a name="map-find-select-reduce-size"></a>
Prefer <code>map</code> over <code>collect</code>, <code>find</code> over <code>detect</code>, <code>select</code> over <code>find_all</code>,
<code>reduce</code> over <code>inject</code> and <code>size</code> over <code>length</code>. This is not a hard
requirement; if the use of the alias enhances readability, it’s ok to use it.
The rhyming methods are inherited from Smalltalk and are not common in other
programming languages. The reason the use of <code>select</code> is encouraged over
<code>find_all</code> is that it goes together nicely with <code>reject</code> and its name is
pretty self-explanatory.</p>
  </li>
  <li>
    <p><a name="count-vs-size"></a>
Don’t use <code>count</code> as a substitute for <code>size</code>. For <code>Enumerable</code> objects other
than <code>Array</code> it will iterate the entire collection in order to determine its
size.</p>

    <p>```Ruby
# bad
some_hash.count</p>

    <h1 id="good-69">good</h1>
    <p>some_hash.size
```</p>
  </li>
  <li>
    <p><a name="flat-map"></a>
Use <code>flat_map</code> instead of <code>map</code> + <code>flatten</code>.  This does not apply for arrays
with a depth greater than 2, i.e.  if <code>users.first.songs == ['a', ['b','c']]</code>,
then use <code>map + flatten</code> rather than <code>flat_map</code>.  <code>flat_map</code> flattens the
array by 1, whereas <code>flatten</code> flattens it all the way.</p>

    <p>```Ruby
# bad
all_songs = users.map(&amp;:songs).flatten.uniq</p>

    <h1 id="good-70">good</h1>
    <p>all_songs = users.flat_map(&amp;:songs).uniq
```</p>
  </li>
  <li>
    <p><a name="reverse-each"></a>
Prefer <code>reverse_each</code> to <code>reverse.each</code> because some classes that <code>include
Enumerable</code> will provide an efficient implementation. Even in the worst case
where a class does not provide a specialized implementation, the general
implementation inherited from <code>Enumerable</code> will be at least as efficient as
using <code>reverse.each</code>.</p>

    <p>```Ruby
# bad
array.reverse.each { … }</p>

    <h1 id="good-71">good</h1>
    <p>array.reverse_each { … }
```</p>
  </li>
</ul>

<h2 id="naming">Naming</h2>

<blockquote>
  <p>The only real difficulties in programming are cache invalidation and
naming things. <br />
– Phil Karlton</p>
</blockquote>

<ul>
  <li>
    <p><a name="english-identifiers"></a>
Name identifiers in English.</p>

    <p>```Ruby
# bad - identifier using non-ascii characters
заплата = 1_000</p>

    <h1 id="bad---identifier-is-a-bulgarian-word-written-with-latin-letters-instead-of-cyrillic">bad - identifier is a Bulgarian word, written with Latin letters (instead of Cyrillic)</h1>
    <p>zaplata = 1_000</p>

    <h1 id="good-72">good</h1>
    <p>salary = 1_000
```</p>
  </li>
  <li>
    <p><a name="snake-case-symbols-methods-vars"></a>
Use <code>snake_case</code> for symbols, methods and variables.</p>

    <p>```Ruby
# bad
:’some symbol’
:SomeSymbol
:someSymbol</p>

    <p>someVar = 5</p>

    <p>def someMethod
  …
end</p>

    <p>def SomeMethod
 …
end</p>

    <h1 id="good-73">good</h1>
    <p>:some_symbol</p>

    <p>def some_method
  …
end
```</p>
  </li>
  <li>
    <p><a name="camelcase-classes"></a>
Use <code>CamelCase</code> for classes and modules.  (Keep acronyms like HTTP, RFC, XML
uppercase.)</p>

    <p>```Ruby
# bad
class Someclass
  …
end</p>

    <p>class Some_Class
  …
end</p>

    <p>class SomeXml
  …
end</p>

    <p>class XmlSomething
  …
end</p>

    <h1 id="good-74">good</h1>
    <p>class SomeClass
  …
end</p>

    <p>class SomeXML
  …
end</p>

    <p>class XMLSomething
  …
end
```</p>
  </li>
  <li>
    <p><a name="snake-case-files"></a>
Use <code>snake_case</code> for naming files, e.g. <code>hello_world.rb</code>.</p>
  </li>
  <li>
    <p><a name="snake-case-dirs"></a>
Use <code>snake_case</code> for naming directories, e.g.
<code>lib/hello_world/hello_world.rb</code>.</p>
  </li>
  <li>
    <p><a name="one-class-per-file"></a>
Aim to have just a single class/module per source file. Name the file name
as the class/module, but replacing CamelCase with snake_case.</p>
  </li>
  <li>
    <p><a name="screaming-snake-case"></a>
Use <code>SCREAMING_SNAKE_CASE</code> for other constants.</p>

    <p>```Ruby
# bad
SomeConst = 5</p>

    <h1 id="good-75">good</h1>
    <p>SOME_CONST = 5
```</p>
  </li>
  <li>
    <p><a name="bool-methods-qmark"></a>
The names of predicate methods (methods that return a boolean value) should
end in a question mark.  (i.e. <code>Array#empty?</code>). Methods that don’t return a
boolean, shouldn’t end in a question mark.</p>
  </li>
  <li>
    <p><a name="dangerous-method-bang"></a>
The names of potentially <em>dangerous</em> methods (i.e. methods that modify
<code>self</code> or the arguments, <code>exit!</code> (doesn’t run the finalizers like <code>exit</code>
does), etc.) should end with an exclamation mark if there exists a safe
version of that <em>dangerous</em> method.</p>

    <p>```Ruby
# bad - there is no matching ‘safe’ method
class Person
  def update!
  end
end</p>

    <h1 id="good-76">good</h1>
    <p>class Person
  def update
  end
end</p>

    <h1 id="good-77">good</h1>
    <p>class Person
  def update!
  end</p>

    <p>def update
  end
end
```</p>
  </li>
  <li>
    <p><a name="safe-because-unsafe"></a>
Define the non-bang (safe) method in terms of the bang (dangerous) one if
possible.</p>

    <p>```Ruby
class Array
  def flatten_once!
    res = []</p>

    <pre><code>each do |e|
  [*e].each { |f| res &lt;&lt; f }
end

replace(res)   end
</code></pre>

    <p>def flatten_once
    dup.flatten_once!
  end
end
```</p>
  </li>
  <li>
    <p><a name="reduce-blocks"></a>
When using <code>reduce</code> with short blocks, name the arguments <code>|a, e|</code>
(accumulator, element).</p>
  </li>
  <li>
    <p><a name="other-arg"></a>
When defining binary operators, name the parameter <code>other</code>(<code>&lt;&lt;</code> and <code>[]</code> are
exceptions to the rule, since their semantics are different).</p>

    <p><code>Ruby
def +(other)
  # body omitted
end
</code></p>
  </li>
</ul>

<h2 id="comments">Comments</h2>

<blockquote>
  <p>Good code is its own best documentation. As you’re about to add a
comment, ask yourself, “How can I improve the code so that this
comment isn’t needed?” Improve the code and then document it to make
it even clearer. <br />
– Steve McConnell</p>
</blockquote>

<ul>
  <li>
    <p><a name="no-comments"></a>
Write self-documenting code and ignore the rest of this section. Seriously!</p>
  </li>
  <li>
    <p><a name="english-comments"></a>
Write comments in English.</p>
  </li>
  <li>
    <p><a name="hash-space"></a>
Use one space between the leading <code>#</code> character of the comment and the text
of the comment.</p>
  </li>
  <li>
    <p><a name="english-syntax"></a>
Comments longer than a word are capitalized and use punctuation. Use <a href="http://en.wikipedia.org/wiki/Sentence_spacing">one
space</a> after periods.</p>
  </li>
  <li>
    <p><a name="no-superfluous-comments"></a>
Avoid superfluous comments.</p>

    <p><code>Ruby
# bad
counter += 1 # Increments counter by one.
</code></p>
  </li>
  <li>
    <p><a name="comment-upkeep"></a>
Keep existing comments up-to-date. An outdated comment is worse than no
comment at all.</p>
  </li>
</ul>

<blockquote>
  <p>Good code is like a good joke - it needs no explanation. <br />
– Russ Olsen</p>
</blockquote>

<ul>
  <li><a name="refactor-dont-comment"></a>
Avoid writing comments to explain bad code. Refactor the code to make it
self-explanatory. (Do or do not - there is no try. –Yoda)</li>
</ul>

<h3 id="comment-annotations">Comment Annotations</h3>

<ul>
  <li>
    <p><a name="annotate-above"></a>
Annotations should usually be written on the line immediately above the
relevant code.</p>
  </li>
  <li>
    <p><a name="annotate-keywords"></a>
The annotation keyword is followed by a colon and a space, then a note
describing the problem.</p>
  </li>
  <li>
    <p><a name="indent-annotations"></a>
If multiple lines are required to describe the problem, subsequent lines
should be indented three spaces after the <code>#</code> (one general plus two for
indentation purpose).</p>

    <p><code>Ruby
def bar
  # FIXME: This has crashed occasionally since v3.2.1. It may
  #   be related to the BarBazUtil upgrade.
  baz(:quux)
end
</code></p>
  </li>
  <li>
    <p><a name="rare-eol-annotations"></a>
In cases where the problem is so obvious that any documentation would be
redundant, annotations may be left at the end of the offending line with no
note. This usage should be the exception and not the rule.</p>

    <p><code>Ruby
def bar
  sleep 100 # OPTIMIZE
end
</code></p>
  </li>
  <li>
    <p><a name="todo"></a>
Use <code>TODO</code> to note missing features or functionality that should be added at
a later date.</p>
  </li>
  <li>
    <p><a name="fixme"></a>
Use <code>FIXME</code> to note broken code that needs to be fixed.</p>
  </li>
  <li>
    <p><a name="optimize"></a>
Use <code>OPTIMIZE</code> to note slow or inefficient code that may cause performance
problems.</p>
  </li>
  <li>
    <p><a name="hack"></a>
Use <code>HACK</code> to note code smells where questionable coding practices were used
and should be refactored away.</p>
  </li>
  <li>
    <p><a name="review"></a>
Use <code>REVIEW</code> to note anything that should be looked at to confirm it is
working as intended. For example: <code>REVIEW: Are we sure this is how the client
does X currently?</code></p>
  </li>
  <li>
    <p><a name="document-annotations"></a>
Use other custom annotation keywords if it feels appropriate, but be sure to
document them in your project’s <code>README</code> or similar.</p>
  </li>
</ul>

<h2 id="classes--modules">Classes &amp; Modules</h2>

<ul>
  <li>
    <p><a name="consistent-classes"></a>
Use a consistent structure in your class definitions.</p>

    <p>```Ruby
class Person
  # extend and include go first
  extend SomeModule
  include AnotherModule</p>

    <p># inner classes
  CustomErrorKlass = Class.new(StandardError)</p>

    <p># constants are next
  SOME_CONSTANT = 20</p>

    <p># afterwards we have attribute macros
  attr_reader :name</p>

    <p># followed by other macros (if any)
  validates :name</p>

    <p># public class methods are next in line
  def self.some_method
  end</p>

    <p># initialization goes between class methods and other instance methods
  def initialize
  end</p>

    <p># followed by other public instance methods
  def some_method
  end</p>

    <p># protected and private methods are grouped near the end
  protected</p>

    <p>def some_protected_method
  end</p>

    <p>private</p>

    <p>def some_private_method
  end
end
```</p>
  </li>
  <li>
    <p><a name="file-classes"></a>
Don’t nest multi line classes within classes. Try to have such nested
classes each in their own file in a folder named like the containing class.</p>

    <p>```Ruby
# bad</p>

    <h1 id="foorb">foo.rb</h1>
    <p>class Foo
  class Bar
    # 30 methods inside
  end</p>

    <p>class Car
    # 20 methods inside
  end</p>

    <p># 30 methods inside
end</p>

    <h1 id="good-78">good</h1>

    <h1 id="foorb-1">foo.rb</h1>
    <p>class Foo
  # 30 methods inside
end</p>

    <h1 id="foobarrb">foo/bar.rb</h1>
    <p>class Foo
  class Bar
    # 30 methods inside
  end
end</p>

    <h1 id="foocarrb">foo/car.rb</h1>
    <p>class Foo
  class Car
    # 20 methods inside
  end
end
```</p>
  </li>
  <li>
    <p><a name="modules-vs-classes"></a>
Prefer modules to classes with only class methods. Classes should be used
only when it makes sense to create instances out of them.</p>

    <p>```Ruby
# bad
class SomeClass
  def self.some_method
    # body omitted
  end</p>

    <p>def self.some_other_method
  end
end</p>

    <h1 id="good-79">good</h1>
    <p>module SomeModule
  module_function</p>

    <p>def some_method
    # body omitted
  end</p>

    <p>def some_other_method
  end
end
```</p>
  </li>
  <li>
    <p><a name="module-function"></a>
Favour the use of <code>module_function</code> over <code>extend self</code> when you want to turn
a module’s instance methods into class methods.</p>

    <p>```Ruby
# bad
module Utilities
  extend self</p>

    <p>def parse_something(string)
    # do stuff here
  end</p>

    <p>def other_utility_method(number, string)
    # do some more stuff
  end
end</p>

    <h1 id="good-80">good</h1>
    <p>module Utilities
  module_function</p>

    <p>def parse_something(string)
    # do stuff here
  end</p>

    <p>def other_utility_method(number, string)
    # do some more stuff
  end
end
```</p>
  </li>
  <li>
    <p><a name="liskov"></a>
When designing class hierarchies make sure that they conform to the <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov
Substitution
Principle</a>.</p>
  </li>
  <li>
    <p><a name="solid-design"></a>
Try to make your classes as
<a href="http://en.wikipedia.org/wiki/SOLID_\(object-oriented_design\)">SOLID</a> as
possible.</p>
  </li>
  <li>
    <p><a name="define-to-s"></a>
Always supply a proper <code>to_s</code> method for classes that represent domain
objects.</p>

    <p>```Ruby
class Person
  attr_reader :first_name, :last_name</p>

    <p>def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end</p>

    <p>def to_s
    “#{@first_name} #{@last_name}”
  end
end
```</p>
  </li>
  <li>
    <p><a name="attr_family"></a>
Use the <code>attr</code> family of functions to define trivial accessors or mutators.</p>

    <p>```Ruby
# bad
class Person
  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end</p>

    <p>def first_name
    @first_name
  end</p>

    <p>def last_name
    @last_name
  end
end</p>

    <h1 id="good-81">good</h1>
    <p>class Person
  attr_reader :first_name, :last_name</p>

    <p>def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end
end
```</p>
  </li>
  <li>
    <p><a name="attr"></a>
Avoid the use of <code>attr</code>. Use <code>attr_reader</code> and <code>attr_accessor</code> instead.</p>

    <p>```Ruby
# bad - creates a single attribute accessor (deprecated in 1.9)
attr :something, true
attr :one, :two, :three # behaves as attr_reader</p>

    <h1 id="good-82">good</h1>
    <p>attr_accessor :something
attr_reader :one, :two, :three
```</p>
  </li>
  <li>
    <p><a name="struct-new"></a>
Consider using <code>Struct.new</code>, which defines the trivial accessors,
constructor and comparison operators for you.</p>

    <p>```Ruby
# good
class Person
  attr_accessor :first_name, :last_name</p>

    <p>def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end
end</p>

    <h1 id="better-1">better</h1>
    <p>Person = Struct.new(:first_name, :last_name) do
end
````</p>
  </li>
  <li>
    <p><a name="no-extend-struct-new"></a>
Don’t extend an instance initialized by <code>Struct.new</code>. Extending it introduces
a superfluous class level and may also introduce weird errors if the file is
required multiple times.</p>

    <p>```Ruby
# bad
class Person &lt; Struct.new(:first_name, :last_name)
end</p>

    <h1 id="good-83">good</h1>
    <p>Person = Struct.new(:first_name, :last_name)
````</p>
  </li>
  <li>
    <p><a name="factory-methods"></a>
Consider adding factory methods to provide additional sensible ways to
create instances of a particular class.</p>

    <p><code>Ruby
class Person
  def self.create(options_hash)
    # body omitted
  end
end
</code></p>
  </li>
  <li>
    <p><a name="duck-typing"></a>
Prefer <a href="http://en.wikipedia.org/wiki/Duck_typing">duck-typing</a> over
inheritance.</p>

    <p>```Ruby
# bad
class Animal
  # abstract method
  def speak
  end
end</p>

    <h1 id="extend-superclass">extend superclass</h1>
    <p>class Duck &lt; Animal
  def speak
    puts ‘Quack! Quack’
  end
end</p>

    <h1 id="extend-superclass-1">extend superclass</h1>
    <p>class Dog &lt; Animal
  def speak
    puts ‘Bau! Bau!’
  end
end</p>

    <h1 id="good-84">good</h1>
    <p>class Duck
  def speak
    puts ‘Quack! Quack’
  end
end</p>

    <p>class Dog
  def speak
    puts ‘Bau! Bau!’
  end
end
```</p>
  </li>
  <li>
    <p><a name="no-class-vars"></a>
Avoid the usage of class (<code>@@</code>) variables due to their “nasty” behavior in
inheritance.</p>

    <p>```Ruby
class Parent
  @@class_var = ‘parent’</p>

    <p>def self.print_class_var
    puts @@class_var
  end
end</p>

    <p>class Child &lt; Parent
  @@class_var = ‘child’
end</p>

    <p>Parent.print_class_var # =&gt; will print “child”
```</p>

    <p>As you can see all the classes in a class hierarchy actually share one
class variable. Class instance variables should usually be preferred
over class variables.</p>
  </li>
  <li>
    <p><a name="visibility"></a>
Assign proper visibility levels to methods (<code>private</code>, <code>protected</code>) in
accordance with their intended usage. Don’t go off leaving everything <code>public</code>
(which is the default). After all we’re coding in <em>Ruby</em> now, not in <em>Python</em>.</p>
  </li>
  <li>
    <p><a name="indent-public-private-protected"></a>
Indent the <code>public</code>, <code>protected</code>, and <code>private</code> methods as much as the method
definitions they apply to. Leave one blank line above the visibility modifier
and one blank line below in order to emphasize that it applies to all methods
below it.</p>

    <p>```Ruby
class SomeClass
  def public_method
    # …
  end</p>

    <p>private</p>

    <p>def private_method
    # …
  end</p>

    <p>def another_private_method
    # …
  end
end
```</p>
  </li>
  <li>
    <p><a name="def-self-class-methods"></a>
Use <code>def self.method</code> to define class methods. This makes the code
easier to refactor since the class name is not repeated.</p>

    <p>```Ruby
class TestClass
  # bad
  def TestClass.some_method
    # body omitted
  end</p>

    <p># good
  def self.some_other_method
    # body omitted
  end</p>

    <p># Also possible and convenient when you
  # have to define many class methods.
  class « self
    def first_method
      # body omitted
    end</p>

    <pre><code>def second_method_etc
  # body omitted
end   end end ```
</code></pre>
  </li>
  <li>
    <p><a name="alias-method-lexically"></a>
Prefer <code>alias</code> when aliasing methods in lexical class scope as the
resolution of <code>self</code> in this context is also lexical, and it communicates
clearly to the user that the indirection of your alias will not be altered
at runtime or by any subclass unless made explicit.</p>

    <p>```Ruby
class Westerner
  def first_name
    @names.first
  end</p>

    <p>alias given_name first_name
end
```</p>

    <p>Since <code>alias</code>, like <code>def</code>, is a keyword, prefer bareword arguments over
symbols or strings. In other words, do <code>alias foo bar</code>, not
<code>alias :foo :bar</code>.</p>

    <p>Also be aware of how Ruby handles aliases and inheritance: an alias
references the method that was resolved at the time the alias was defined;
it is not dispatched dynamically.</p>

    <p><code>Ruby
class Fugitive &lt; Westerner
  def first_name
    'Nobody'
  end
end
</code></p>

    <p>In this example, <code>Fugitive#given_name</code> would still call the original
<code>Westerner#first_name</code> method, not <code>Fugitive#first_name</code>. To override the
behavior of <code>Fugitive#given_name</code> as well, you’d have to redefine it in the
derived class.</p>

    <p>```Ruby
class Fugitive &lt; Westerner
  def first_name
    ‘Nobody’
  end</p>

    <p>alias given_name first_name
end
```</p>
  </li>
  <li>
    <p><a name="alias-method"></a>
Always use <code>alias_method</code> when aliasing methods of modules, classes, or
singleton classes at runtime, as the lexical scope of <code>alias</code> leads to
unpredictability in these cases.</p>

    <p>```Ruby
module Mononymous
  def self.included(other)
    other.class_eval { alias_method :full_name, :given_name }
  end
end</p>

    <p>class Sting &lt; Westerner
  include Mononymous
end
```</p>
  </li>
</ul>

<h2 id="exceptions">Exceptions</h2>

<ul>
  <li>
    <p><a name="fail-method"></a>
Signal exceptions using the <code>fail</code> method. Use <code>raise</code> only when catching an
exception and re-raising it (because here you’re not failing, but explicitly
and purposefully raising an exception).</p>

    <p><code>Ruby
begin
  fail 'Oops'
rescue =&gt; error
  raise if error.message != 'Oops'
end
</code></p>
  </li>
  <li>
    <p><a name="no-explicit-runtimeerror"></a>
Don’t specify <code>RuntimeError</code> explicitly in the two argument version of
<code>fail/raise</code>.</p>

    <p>```Ruby
# bad
fail RuntimeError, ‘message’</p>

    <h1 id="good---signals-a-runtimeerror-by-default">good - signals a RuntimeError by default</h1>
    <p>fail ‘message’
```</p>
  </li>
  <li>
    <p><a name="exception-class-messages"></a>
Prefer supplying an exception class and a message as two separate arguments
to <code>fail/raise</code>, instead of an exception instance.</p>

    <p>```Ruby
# bad
fail SomeException.new(‘message’)
# Note that there is no way to do <code>fail SomeException.new('message'), backtrace</code>.</p>

    <h1 id="good-85">good</h1>
    <p>fail SomeException, ‘message’
# Consistent with <code>fail SomeException, 'message', backtrace</code>.
```</p>
  </li>
  <li>
    <p><a name="no-return-ensure"></a>
Do not return from an <code>ensure</code> block. If you explicitly return from a method
inside an <code>ensure</code> block, the return will take precedence over any exception
being raised, and the method will return as if no exception had been raised at
all. In effect, the exception will be silently thrown away.</p>

    <p><code>Ruby
def foo
  fail
ensure
  return 'very bad idea'
end
</code></p>
  </li>
  <li>
    <p><a name="begin-implicit"></a>
Use <em>implicit begin blocks</em> where possible.</p>

    <p>```Ruby
# bad
def foo
  begin
    # main logic goes here
  rescue
    # failure handling goes here
  end
end</p>

    <h1 id="good-86">good</h1>
    <p>def foo
  # main logic goes here
rescue
  # failure handling goes here
end
```</p>
  </li>
  <li>
    <p><a name="contingency-methods"></a>
Mitigate the proliferation of <code>begin</code> blocks by using <em>contingency methods</em>
(a term coined by Avdi Grimm).</p>

    <p>```Ruby
# bad
begin
  something_that_might_fail
rescue IOError
  # handle IOError
end</p>

    <p>begin
  something_else_that_might_fail
rescue IOError
  # handle IOError
end</p>

    <h1 id="good-87">good</h1>
    <p>def with_io_error_handling
   yield
rescue IOError
  # handle IOError
end</p>

    <p>with_io_error_handling { something_that_might_fail }</p>

    <p>with_io_error_handling { something_else_that_might_fail }
```</p>
  </li>
  <li>
    <p><a name="dont-hide-exceptions"></a>
Don’t suppress exceptions.</p>

    <p>```Ruby
# bad
begin
  # an exception occurs here
rescue SomeError
  # the rescue clause does absolutely nothing
end</p>

    <h1 id="bad-10">bad</h1>
    <p>do_something rescue nil
```</p>
  </li>
  <li>
    <p><a name="no-rescue-modifiers"></a>
Avoid using <code>rescue</code> in its modifier form.</p>

    <p>```Ruby
# bad - this catches exceptions of StandardError class and its descendant classes
read_file rescue handle_error($!)</p>

    <h1 id="good---this-catches-only-the-exceptions-of-errnoenoent-class-and-its-descendant-classes">good - this catches only the exceptions of Errno::ENOENT class and its descendant classes</h1>
    <p>def foo
  read_file
rescue Errno::ENOENT =&gt; ex
  handle_error(ex)
end
```</p>
  </li>
  <li>
    <p><a name="no-exceptional-flows"></a>
Don’t use exceptions for flow of control.</p>

    <p>```Ruby
# bad
begin
  n / d
rescue ZeroDivisionError
  puts ‘Cannot divide by 0!’
end</p>

    <h1 id="good-88">good</h1>
    <p>if d.zero?
  puts ‘Cannot divide by 0!’
else
  n / d
end
```</p>
  </li>
  <li>
    <p><a name="no-blind-rescues"></a>
Avoid rescuing the <code>Exception</code> class.  This will trap signals and calls to
<code>exit</code>, requiring you to <code>kill -9</code> the process.</p>

    <p>```Ruby
# bad
begin
  # calls to exit and kill signals will be caught (except kill -9)
  exit
rescue Exception
  puts “you didn’t really want to exit, right?”
  # exception handling
end</p>

    <h1 id="good-89">good</h1>
    <p>begin
  # a blind rescue rescues from StandardError, not Exception as many
  # programmers assume.
rescue =&gt; e
  # exception handling
end</p>

    <h1 id="also-good-2">also good</h1>
    <p>begin
  # an exception occurs here</p>

    <p>rescue StandardError =&gt; e
  # exception handling
end
```</p>
  </li>
  <li>
    <p><a name="exception-ordering"></a>
Put more specific exceptions higher up the rescue chain, otherwise they’ll
never be rescued from.</p>

    <p>```Ruby
# bad
begin
  # some code
rescue Exception =&gt; e
  # some handling
rescue StandardError =&gt; e
  # some handling that will never be executed
end</p>

    <h1 id="good-90">good</h1>
    <p>begin
  # some code
rescue StandardError =&gt; e
  # some handling
rescue Exception =&gt; e
  # some handling
end
```</p>
  </li>
  <li>
    <p><a name="release-resources"></a>
Release external resources obtained by your program in an <code>ensure</code> block.</p>

    <p><code>Ruby
f = File.open('testfile')
begin
  # .. process
rescue
  # .. handle error
ensure
  f.close if f
end
</code></p>
  </li>
  <li>
    <p><a name="auto-release-resources"></a>
Use versions of resource obtaining methods that do automatic
resource cleanup when possible.</p>

    <p>```Ruby
# bad - you need to close the file descriptor explicitly
f = File.open(‘testfile’)
  # …
f.close</p>

    <h1 id="good---the-file-descriptor-is-closed-automatically">good - the file descriptor is closed automatically</h1>
    <p>File.open(‘testfile’) do |f|
  # …
end
```</p>
  </li>
  <li>
    <p><a name="standard-exceptions"></a>
Favour the use of exceptions for the standard library over introducing new
exception classes.</p>
  </li>
</ul>

<h2 id="collections">Collections</h2>

<ul>
  <li>
    <p><a name="literal-array-hash"></a>
Prefer literal array and hash creation notation (unless you need to pass
parameters to their constructors, that is).</p>

    <p>```Ruby
# bad
arr = Array.new
hash = Hash.new</p>

    <h1 id="good-91">good</h1>
    <p>arr = []
hash = {}
```</p>
  </li>
  <li>
    <p><a name="percent-w"></a>
Prefer <code>%w</code> to the literal array syntax when you need an array of words
(non-empty strings without spaces and special characters in them).  Apply this
rule only to arrays with two or more elements.</p>

    <p>```Ruby
# bad
STATES = [‘draft’, ‘open’, ‘closed’]</p>

    <h1 id="good-92">good</h1>
    <p>STATES = %w(draft open closed)
```</p>
  </li>
  <li>
    <p><a name="percent-i"></a>
Prefer <code>%i</code> to the literal array syntax when you need an array of symbols
(and you don’t need to maintain Ruby 1.9 compatibility). Apply this rule only
to arrays with two or more elements.</p>

    <p>```Ruby
# bad
STATES = [:draft, :open, :closed]</p>

    <h1 id="good-93">good</h1>
    <p>STATES = %i(draft open closed)
```</p>
  </li>
  <li>
    <p><a name="no-trailing-array-commas"></a>
Avoid comma after the last item of an <code>Array</code> or <code>Hash</code> literal, especially
when the items are not on separate lines.</p>

    <p>```Ruby
# bad - easier to move/add/remove items, but still not preferred
VALUES = [
           1001,
           2020,
           3333,
         ]</p>

    <h1 id="bad-11">bad</h1>
    <p>VALUES = [1001, 2020, 3333, ]</p>

    <h1 id="good-94">good</h1>
    <p>VALUES = [1001, 2020, 3333]
```</p>
  </li>
  <li>
    <p><a name="no-gappy-arrays"></a>
Avoid the creation of huge gaps in arrays.</p>

    <p><code>Ruby
arr = []
arr[100] = 1 # now you have an array with lots of nils
</code></p>
  </li>
  <li>
    <p><a name="first-and-last"></a>
When accessing the first or last element from an array, prefer <code>first</code> or
<code>last</code> over <code>[0]</code> or <code>[-1]</code>.</p>
  </li>
  <li>
    <p><a name="set-vs-array"></a>
Use <code>Set</code> instead of <code>Array</code> when dealing with unique elements. <code>Set</code>
implements a collection of unordered values with no duplicates. This is a
hybrid of <code>Array</code>’s intuitive inter-operation facilities and <code>Hash</code>’s fast
lookup.</p>
  </li>
  <li>
    <p><a name="symbols-as-keys"></a>
Prefer symbols instead of strings as hash keys.</p>

    <p>```Ruby
# bad
hash = { ‘one’ =&gt; 1, ‘two’ =&gt; 2, ‘three’ =&gt; 3 }</p>

    <h1 id="good-95">good</h1>
    <p>hash = { one: 1, two: 2, three: 3 }
```</p>
  </li>
  <li>
    <p><a name="no-mutable-keys"></a>
Avoid the use of mutable objects as hash keys.</p>
  </li>
  <li>
    <p><a name="hash-literals"></a>
Use the Ruby 1.9 hash literal syntax when your hash keys are symbols.</p>

    <p>```Ruby
# bad
hash = { :one =&gt; 1, :two =&gt; 2, :three =&gt; 3 }</p>

    <h1 id="good-96">good</h1>
    <p>hash = { one: 1, two: 2, three: 3 }
```</p>
  </li>
  <li>
    <p><a name="no-mixed-hash-syntaces"></a>
Don’t mix the Ruby 1.9 hash syntax with hash rockets in the same hash
literal. When you’ve got keys that are not symbols stick to the hash rockets
syntax.</p>

    <p>```Ruby
# bad
{ a: 1, ‘b’ =&gt; 2 }</p>

    <h1 id="good-97">good</h1>
    <p>{ :a =&gt; 1, ‘b’ =&gt; 2 }
```</p>
  </li>
  <li>
    <p><a name="hash-key"></a>
Use <code>Hash#key?</code> instead of <code>Hash#has_key?</code> and <code>Hash#value?</code> instead of
<code>Hash#has_value?</code>. As noted
<a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/43765">here</a> by
Matz, the longer forms are considered deprecated.</p>

    <p>```Ruby
# bad
hash.has_key?(:test)
hash.has_value?(value)</p>

    <h1 id="good-98">good</h1>
    <p>hash.key?(:test)
hash.value?(value)
```</p>
  </li>
  <li>
    <p><a name="hash-fetch"></a>
Use <code>Hash#fetch</code> when dealing with hash keys that should be present.</p>

    <p>```Ruby
heroes = { batman: ‘Bruce Wayne’, superman: ‘Clark Kent’ }
# bad - if we make a mistake we might not spot it right away
heroes[:batman] # =&gt; “Bruce Wayne”
heroes[:supermann] # =&gt; nil</p>

    <h1 id="good---fetch-raises-a-keyerror-making-the-problem-obvious">good - fetch raises a KeyError making the problem obvious</h1>
    <p>heroes.fetch(:supermann)
```</p>
  </li>
  <li>
    <p><a name="hash-fetch-defaults"></a>
Introduce default values for hash keys via <code>Hash#fetch</code> as opposed to using
custom logic.</p>

    <p>```Ruby
batman = { name: ‘Bruce Wayne’, is_evil: false }</p>

    <h1 id="bad---if-we-just-use--operator-with-falsy-value-we-wont-get-the-expected-result">bad - if we just use || operator with falsy value we won’t get the expected result</h1>
    <p>batman[:is_evil] || true # =&gt; true</p>

    <h1 id="good---fetch-work-correctly-with-falsy-values">good - fetch work correctly with falsy values</h1>
    <p>batman.fetch(:is_evil, true) # =&gt; false
```</p>
  </li>
  <li>
    <p><a name="use-hash-blocks"></a>
Prefer the use of the block instead of the default value in <code>Hash#fetch</code>
if the code that has to be evaluated may have side effects or be expensive.</p>

    <p>```Ruby
batman = { name: ‘Bruce Wayne’ }</p>

    <h1 id="bad---if-we-use-the-default-value-we-eager-evaluate-it">bad - if we use the default value, we eager evaluate it</h1>
    <p># so it can slow the program down if done multiple times
batman.fetch(:powers, obtain_batman_powers) # obtain_batman_powers is an expensive call</p>

    <h1 id="good---blocks-are-lazy-evaluated-so-only-triggered-in-case-of-keyerror-exception">good - blocks are lazy evaluated, so only triggered in case of KeyError exception</h1>
    <p>batman.fetch(:powers) { obtain_batman_powers }
```</p>
  </li>
  <li>
    <p><a name="hash-values-at"></a>
Use <code>Hash#values_at</code> when you need to retrieve several values consecutively
from a hash.</p>

    <p>```Ruby
# bad
email = data[‘email’]
username = data[‘nickname’]</p>

    <h1 id="good-99">good</h1>
    <p>email, username = data.values_at(‘email’, ‘nickname’)
```</p>
  </li>
  <li>
    <p><a name="ordered-hashes"></a>
Rely on the fact that as of Ruby 1.9 hashes are ordered.</p>
  </li>
  <li>
    <p><a name="no-modifying-collections"></a>
Do not modify a collection while traversing it.</p>
  </li>
  <li>
    <p><a name="accessing-elements-directly"></a>
When accessing elements of a collection, avoid direct access
via <code>[n]</code> by using an alternate form of the reader method if it is
supplied. This guards you from calling <code>[]</code> on <code>nil</code>.</p>

    <p>```Ruby
# bad
Regexp.last_match[1]</p>

    <h1 id="good-100">good</h1>
    <p>Regexp.last_match(1)
```</p>
  </li>
  <li>
    <p><a name="provide-alternate-accessor-to-collections"></a>
When providing an accessor for a collection, provide an alternate form
to save users from checking for <code>nil</code> before accessing an element in
the collection.</p>

    <p>```Ruby
# bad
def awesome_things
  @awesome_things
end</p>

    <h1 id="good-101">good</h1>
    <p>def awesome_things(index = nil)
  if index &amp;&amp; @awesome_things
    @awesome_things[index]
  else
    @awesome_things
  end
end
```</p>
  </li>
</ul>

<h2 id="strings">Strings</h2>

<ul>
  <li>
    <p><a name="string-interpolation"></a>
Prefer string interpolation and string formatting instead of string
concatenation:</p>

    <p>```Ruby
# bad
email_with_name = user.name + ‘ &lt;’ + user.email + ‘&gt;’</p>

    <h1 id="good-102">good</h1>
    <p>email_with_name = “#{user.name} &lt;#{user.email}&gt;”</p>

    <h1 id="good-103">good</h1>
    <p>email_with_name = format(‘%s &lt;%s&gt;’, user.name, user.email)
```</p>
  </li>
  <li>
    <p><a name="string-interpolation"></a>
With interpolated expressions, there should be no padded-spacing inside the braces.</p>

    <p>```Ruby
# bad
“From: #{ user.first_name }, #{ user.last_name }”</p>

    <h1 id="good-104">good</h1>
    <p>“From: #{user.first_name}, #{user.last_name}”
```</p>
  </li>
  <li>
    <p><a name="consistent-string-literals"></a>
Adopt a consistent string literal quoting style. There are two popular
styles in the Ruby community, both of which are considered good - single
quotes by default (Option A) and double quotes by default (Option B).</p>

    <ul>
      <li>
        <p><strong>(Option A)</strong> Prefer single-quoted strings when you don’t need
string interpolation or special symbols such as <code>\t</code>, <code>\n</code>, <code>'</code>,
etc.</p>

        <p>```Ruby
# bad
name = “Bozhidar”</p>

        <h1 id="good-105">good</h1>
        <p>name = ‘Bozhidar’
```</p>
      </li>
      <li>
        <p><strong>(Option B)</strong> Prefer double-quotes unless your string literal
contains <code>"</code> or escape characters you want to suppress.</p>

        <p>```Ruby
# bad
name = ‘Bozhidar’</p>

        <h1 id="good-106">good</h1>
        <p>name = “Bozhidar”
```</p>
      </li>
    </ul>

    <p>The string literals in this guide are aligned with the first style.</p>
  </li>
  <li>
    <p><a name="no-character-literals"></a>
Don’t use the character literal syntax <code>?x</code>. Since Ruby 1.9 it’s basically
redundant - <code>?x</code> would interpreted as <code>'x'</code> (a string with a single character
in it).</p>

    <p>```Ruby
# bad
char = ?c</p>

    <h1 id="good-107">good</h1>
    <p>char = ‘c’
```</p>
  </li>
  <li>
    <p><a name="curlies-interpolate"></a>
Don’t leave out <code>{}</code> around instance and global variables being interpolated
into a string.</p>

    <p>```Ruby
class Person
  attr_reader :first_name, :last_name</p>

    <p>def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end</p>

    <p># bad - valid, but awkward
  def to_s
    “#@first_name #@last_name”
  end</p>

    <p># good
  def to_s
    “#{@first_name} #{@last_name}”
  end
end</p>

    <p>$global = 0
# bad
puts “$global = #$global”</p>

    <h1 id="good-108">good</h1>
    <p>puts “$global = #{$global}”
```</p>
  </li>
  <li>
    <p><a name="no-to-s"></a>
Don’t use <code>Object#to_s</code> on interpolated objects. It’s invoked on them
automatically.</p>

    <p>```Ruby
# bad
message = “This is the #{result.to_s}.”</p>

    <h1 id="good-109">good</h1>
    <p>message = “This is the #{result}.”
```</p>
  </li>
  <li>
    <p><a name="concat-strings"></a>
Avoid using <code>String#+</code> when you need to construct large data chunks.
Instead, use <code>String#&lt;&lt;</code>. Concatenation mutates the string instance in-place
and is always faster than <code>String#+</code>, which creates a bunch of new string
objects.</p>

    <p>```Ruby
# good and also fast
html = ‘’
html « ‘&lt;h1&gt;Page title&lt;/h1&gt;’</p>

    <p>paragraphs.each do |paragraph|
  html « “&lt;p&gt;#{paragraph}&lt;/p&gt;”
end
```</p>
  </li>
  <li>
    <p><a name="dont-abuse-gsub"></a>
Don’t use <code>String#gsub</code> in scenarios in which you can use a faster more specialized alternative.</p>

    <p>```Ruby
  url = ‘http://example.com’
  str = ‘lisp-case-rules’</p>

    <p># bad
  url.gsub(“http://”, “https://”)
  str.gsub(“-“, “_”)</p>

    <p># good
  url.sub(“http://”, “https://”)
  str.tr(“-“, “_”)
  ```</p>
  </li>
  <li>
    <p><a name="heredocs"></a>
When using heredocs for multi-line strings keep in mind the fact that they
preserve leading whitespace. It’s a good practice to employ some margin based
on which to trim the excessive whitespace.</p>

    <p><code>Ruby
code = &lt;&lt;-END.gsub(/^\s+\|/, '')
  |def test
  |  some_method
  |  other_method
  |end
END
# =&gt; "def test\n  some_method\n  other_method\nend\n"
</code></p>
  </li>
</ul>

<h2 id="regular-expressions">Regular Expressions</h2>

<h3 id="avoid-regular-expressions-where-strings-will-do">Avoid regular expressions where strings will do</h3>

<p>Don’t use regular expressions if you just need plain text search in string:
<code>string['text']</code></p>

<h3 id="matching-simple-strings">Matching simple Strings</h3>

<p>For simple constructions you can use regexp directly through string index.</p>

<p><code>Ruby
match = string[/regexp/]             # get content of matched regexp
first_group = string[/text(grp)/, 1] # get content of captured group
string[/text (grp)/, 1] = 'replace'  # string =&gt; 'text replace'
</code></p>

<h3 id="capturing-results">Capturing results</h3>

<p>Use non-capturing groups when you don’t use captured result of parentheses.</p>

<p><code>Ruby
/(first|second)/   # bad
/(?:first|second)/ # good
</code></p>

<h3 id="avoid-global-variables">Avoid global variables</h3>

<p>Don’t use the cryptic Perl-legacy variables denoting last regexp group
matches (<code>$1</code>, <code>$2</code>, etc). Use <code>Regexp.last_match(n)</code> instead.</p>

<p>```Ruby
/(regexp)/ =~ string
…</p>

<h1 id="bad-12">bad</h1>
<p>process $1</p>

<h1 id="good-110">good</h1>
<p>process Regexp.last_match(1)
```</p>

<h3 id="avoid-numbered-matches">Avoid numbered matches</h3>

<p>Avoid using numbered groups as it can be hard to track what they contain.
Named groups can be used instead.</p>

<p>```Ruby
# bad
/(regexp)/ =~ string
…
process Regexp.last_match(1)</p>

<h1 id="good-111">good</h1>
<p>/(?<meaningful_var>regexp)/ =~ string
...
process meaningful_var
```</meaningful_var></p>

<h3 id="dont-escape-everything">Don’t escape everything</h3>

<p>Character classes have only a few special characters you should care about:
  <code>^</code>, <code>-</code>, <code>\</code>, <code>]</code>, so don’t escape <code>.</code> or brackets in <code>[]</code>.</p>

<h3 id="line-vs-string-startending">Line VS String start/ending</h3>

<p>Be careful with <code>^</code> and <code>$</code> as they match start/end of line, not string
endings.  If you want to match the whole string use: <code>\A</code> and <code>\z</code> (not to be
confused with <code>\Z</code> which is the equivalent of <code>/\n?\z/</code>).</p>

<p><code>Ruby
string = "some injection\nusername"
string[/^username$/]   # matches
string[/\Ausername\z/] # doesn't match
</code></p>

<h3 id="complex-expressions">Complex expressions</h3>

<p>Use <code>x</code> modifier for complex regexps. This makes them more readable and you
can add some useful comments. Just be careful as spaces are ignored.</p>

<p><code>Ruby
regexp = /
  start         # some text
  \s            # white space char
  (group)       # first group
  (?:alt1|alt2) # some alternation
  end
/x
 </code></p>

<h3 id="substituting-values-in-strings">Substituting values in Strings</h3>

<p>For complex replacements <code>sub</code>/<code>gsub</code> can be used with block or hash.</p>

<h2 id="percent-literals-span-classlabel-label--differentdifferentspan">Percent Literals <span class="label label--different">different</span></h2>

<h3 id="single-line-interpolated-strings">Single line interpolated Strings</h3>

<p>Use <code>%{}</code>(it’s a shorthand for <code>%Q</code>) for single-line strings which require
both interpolation and embedded double-quotes. For multi-line strings, prefer
heredocs.</p>

<p>```Ruby
# bad (no interpolation needed)
%{&lt;div class="text"&gt;Some text&lt;/div&gt;}
# should be ‘&lt;div class="text"&gt;Some text&lt;/div&gt;’</p>

<h1 id="bad-no-double-quotes">bad (no double-quotes)</h1>
<p>%{This is #{quality} style}
# should be “This is #{quality} style”</p>

<h1 id="bad-multiple-lines">bad (multiple lines)</h1>
<p>%{&lt;div&gt;\n<span class="big">#{exclamation}</span>\n&lt;/div&gt;}
# should be a heredoc.</p>

<h1 id="good-requires-interpolation-has-quotes-single-line">good (requires interpolation, has quotes, single line)</h1>
<p>%{&lt;tr&gt;&lt;td class="name"&gt;#{name}&lt;/td&gt;}
```</p>

<h3 id="percent-q">Percent Q</h3>

<p>Avoid <code>%q</code> unless you have a string with both <code>'</code> and <code>"</code> in it. Regular
string literals are more readable and should be preferred unless a lot of
characters would have to be escaped in them.</p>

<p>```Ruby
# bad
name = %q(Bruce Wayne)
time = %q(8 o’clock)
question = %q(“What did you say?”)</p>

<h1 id="good-112">good</h1>
<p>name = ‘Bruce Wayne’
time = “8 o’clock”
question = ‘“What did you say?”’
```</p>

<h3 id="percent-r">Percent R</h3>

<p>Use <code>%r</code> only for regular expressions matching <em>at least</em> one ‘/’
character.</p>

<p>```Ruby
# bad
%r{\s+}</p>

<h1 id="good-113">good</h1>
<p>%r{^/(.<em>)$}
%r{^/blog/2011/(.</em>)$}
```</p>

<h3 id="percent-x">Percent X</h3>

<p>Avoid the use of <code>%x</code> unless you’re going to invoke a command with
backquotes in it(which is rather unlikely).</p>

<p>```Ruby
# bad
date = %x(date)</p>

<h1 id="good-114">good</h1>
<p>date = <code>date</code>
echo = %x(echo <code>date</code>)
```</p>

<h3 id="percent-s">Percent S</h3>

<p>Avoid the use of <code>%s</code>. It seems that the community has decided <code>:"some
string"</code> is the preferred way to create a symbol with spaces in it.</p>

<h3 id="delimiting-literals-span-classlabel-label--differentdifferentspan">Delimiting literals <span class="label label--different">different</span></h3>

<p>Prefer <code>{}</code> as delimiters for all <code>%</code> literals, except <code>%w</code>.</p>

<p>Since <code>%w</code> and <code>%W</code> are both used to create Arrays, using <code>[]</code> brackets is better in
  this case.</p>

<p><code>ruby
string  = %Q{Hello world} # =&gt; "Hello world"
regexp  = %r{\w+} # =&gt; /\w+/
array   = %w[ one two three ] # =&gt; ["one", "two", "three"]
symbols = %i[ one two three ] # =&gt; [:one, :two, :three]
</code></p>

<p>```Ruby
# bad
%w[one two three]
%q{“Test’s king!”, John said.}</p>

<h1 id="good-115">good</h1>
<p>%w(one two three)
%q(“Test’s king!”, John said.)
```</p>

<h2 id="metaprogramming">Metaprogramming</h2>

<h3 id="where-possible-dont">Where possible, don’t!</h3>

<p>Avoid needless metaprogramming.</p>

<h3 id="dont-monkey-patch-others-code">Don’t monkey-patch others’ code</h3>

<p>Do not mess around in core classes when writing libraries. (Do not
monkey-patch them.)</p>

<h3 id="using-classeval">Using <code>class_eval</code></h3>

<p>The block form of <code>class_eval</code> is preferable to the string-interpolated
form.  - when you use the string-interpolated form, always supply <code>__FILE__</code>
and <code>__LINE__</code>, so that your backtraces make sense:</p>

<p><code>ruby
class_eval 'def use_relative_model_naming?; true; end', __FILE__, __LINE__
</code></p>

<ul>
  <li><code>define_method</code> is preferable to <code>class_eval{ def ... }</code></li>
</ul>

<h3 id="metaprogramming-methods-as-strings">Metaprogramming methods as strings</h3>

<p>When using <code>class_eval</code> (or other <code>eval</code>) with string interpolation, add a
comment block showing its appearance if interpolated (a practice used in Rails
code):</p>

<p>```ruby
# from activesupport/lib/active_support/core_ext/string/output_safety.rb
UNSAFE_STRING_METHODS.each do |unsafe_method|
  if ‘String’.respond_to?(unsafe_method)
    class_eval «-EOT, <strong>FILE</strong>, <strong>LINE</strong> + 1
      def #{unsafe_method}(<em>params, &amp;block)       # def capitalize(</em>params, &amp;block)
        to_str.#{unsafe_method}(<em>params, &amp;block)  #   to_str.capitalize(</em>params, &amp;block)
      end                                       # end</p>

<pre><code>  def #{unsafe_method}!(*params)              # def capitalize!(*params)
    @dirty = true                           #   @dirty = true
    super                                   #   super
  end                                       # end
EOT   end end ```
</code></pre>

<h3 id="avoid-hijacking-methodmissing-span-classlabel-label--differentdifferentspan">Avoid hijacking <code>method_missing</code> <span class="label label--different">different</span></h3>

<p>Avoid using <code>method_missing</code> for metaprogramming because backtraces become
messy, the behavior is not listed in <code>#methods</code>, and misspelled method calls
might silently work, e.g. <code>nukes.launch_state = false</code>. Consider using
delegation, proxy, or <code>define_method</code> instead.</p>

<p>If you must use
<code>method_missing</code>:</p>

<ul>
  <li>Document the meta-methods (See TomDoc’s Signature section)  <span class="label label--different">different</span></li>
  <li>Be sure to <a href="http://blog.marc-andre.ca/2010/11/methodmissing-politely.html">also define <code>respond_to_missing?</code></a></li>
  <li>Only catch methods with a well-defined prefix, such as <code>find_by_*</code> – make your code as assertive as possible.</li>
  <li>Call <code>super</code> at the end of your statement</li>
  <li>Delegate to assertive, non-magical methods:</li>
</ul>

<p>```ruby
# bad
def method_missing?(meth, *params, &amp;block)
  if /^find_by_(?<prop>.*)/ =~ meth
    # ... lots of code to do a find_by
  else
    super
  end
end</prop></p>

<h1 id="good-116">good</h1>
<p>def method_missing?(meth, *params, &amp;block)
  if /^find_by_(?<prop>.*)/ =~ meth
    find_by(prop, *params, &amp;block)
  else
    super
  end
end</prop></p>

<h1 id="best-of-all-though-would-to-definemethod-as-each-findable-attribute-is-declared">best of all, though, would to define_method as each findable attribute is declared</h1>
<p>```</p>

<h3 id="prefer-publicsend">Prefer <code>public_send</code></h3>

<p>Prefer <code>public_send</code> over <code>send</code> so as not to circumvent <code>private</code>/<code>protected</code> visibility.</p>

<h2 id="misc">Misc</h2>

<h3 id="stay-safe">Stay safe</h3>

<p>Write <code>ruby -w</code> safe code.</p>

<h3 id="avoid-hashes-as-optional-parameters">Avoid hashes as optional parameters</h3>

<p>Avoid hashes as optional parameters. Does the method do too much? (Object
initializers are exceptions for this rule).</p>

<h3 id="no-more-than-10-loc-per-method">No more than 10 LOC per method</h3>

<p>Avoid methods longer than 10 LOC (lines of code). Ideally, most methods will
be shorter than 5 LOC. Empty lines do not contribute to the relevant LOC.</p>

<h3 id="no-more-than-4-params">No more than 4 params</h3>

<p>Avoid parameter lists longer than four parameters.</p>

<h3 id="avoid-global-methods-period">Avoid global methods. Period.</h3>

<p>If you really need “global” methods, add them to Kernel and make them
private.</p>

<h3 id="avoid-global-variables-where-possible">Avoid global variables where possible</h3>

<p>It’s very uncommon that a global variable is the right tool for what you’re trying to
  achieve.</p>

<p>Does the variable you’re storing have a logical namespace that it belongs to?
  Use module instance variables instead of global variables.</p>

<p>```Ruby
# bad
$foo_bar = 1</p>

<h1 id="good-117">good</h1>
<p>module Foo
  class « self
    attr_accessor :bar
  end
end</p>

<p>Foo.bar = 1
```</p>

<ul>
  <li>Use <code>OptionParser</code></li>
</ul>

<p>Use <code>OptionParser</code> for parsing complex command line options and <code>ruby -s</code>
  for trivial command line options.</p>

<h3 id="use-timenow">Use <code>Time.now</code></h3>

<p>Prefer <code>Time.now</code> over <code>Time.new</code> when retrieving the current system time.</p>

<h3 id="do-not-mutate-parameters">Do not mutate parameters</h3>

<p>Do not mutate parameters unless that is the purpose of the method.</p>

<p>``` ruby
# bad
def my_method(string)
  better_string = string.gsub!(/foo/, “bar”)
  return better_string
end</p>

<h1 id="good-118">good</h1>
<p>def my_method(string)
  better_string = string.gsub(/foo/, “bar”)
  return better_string
end</p>

<p>```</p>

<h3 id="dont-nest-more-than-3x">Don’t nest more than 3x</h3>

<p>Avoid more than three levels of block nesting.</p>

<h3 id="be-consistent">Be consistent</h3>

<p>Be consistent. In an ideal world, be consistent with these guidelines.</p>

<p>Consistency will help us work together more productively as a team.</p>

<h3 id="but-above-all">But, above all…</h3>

<p>Use common sense.</p>

        </div>
      </div>
    </div>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-26961925-4', 'auto');
  ga('send', 'pageview');

</script>
  </body>
</html>